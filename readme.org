#+TITLE: Recursive Regexp Raptor (regexp3)
#+AUTHOR: nasciiboy
#+LANGUAGE: es
#+STARTUP: showall
#+OPTIONS: H:5 num:nil html-postamble:nil html-style:nil html-scripts:nil

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y
  reemplazo de expresiones regulares escrita en C, buscando los
  siguientes lineamientos:

  - Cumplir con la mayoria de funciones esperadas por una libreria de
    este tipo.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar peticion explicita de memoria dinamica.

  - Ser util como material de aprendizaje.

** Motivacion

   Partiendo de que C no dispone de una libreria estandar de
   expresiones regulares, se planteo la busqueda de una alternativa
   funcional de la cual aprender un poco, GNU tiene tanto gawk como la
   libreria regexp, sin embargo el autor de este trabajo (que igual y
   es un poco retard) encontro en ambas codigo rebuscado y mistico
   repartido en varios ficheros, llenos de macros y variables
   cripticas.

   La siguiente opcion fue [[https://github.com/cesanta/slre][slre]] cuya principal cararacteristica
   promocional es tener codigo compacto, aunque no mas claro, que
   ademas fallaba si existia un nivel de anidamiento siguiente al
   previo es decir:

   #+BEGIN_EXAMPLE
     (((a|b)))((x|b))
     = 1 =====        OK
              = 2 === ERROR
   #+END_EXAMPLE

   desepcionado y tras un retiro a la isla de la meditacion onanista
   el autor se propuso hacer su propia libreria con casinos y
   colegialas japonesas.

** Desarrollo y pruebas

   Se ha echo uso del "editor" GNU Emacs y el compilador gcc version
   5.3.1, corriendo en fedora 23.

   para compilar solo hace falta un

   #+BEGIN_SRC sh
     gcc test.c regexp3.c
   #+END_SRC

   para la ejecucion basta un confiable

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  La unica funcion de busqueda es =regexp3= aqui su prototipo:

  #+BEGIN_SRC c
    int regexp3( char *line, char *exp );
  #+END_SRC

  - line :: apuntador a cadena sobre la que efectuar la busqueda, debe
            finalizar con el signo de terminacion '\0'.

  - exp  :: apuntador a cadena que contiene la expresion regular de
            busqueda, debe finalizar con el signo de terminacion '\0'.


  La funcion regresa el numero de coincidencias localizadas dentro del
  argumento =line= es decir de =0= (ninguna) a =n= coincidencias.

  La sintaxis de la exprecion regular puede contener:

  - busqueda de texto /simple/ en cualquier lugar de una linea:

    #+BEGIN_SRC c
      regexp3( "linea simple", "a s" );
    #+END_SRC

  - busqueda posicional al inicio '^exp'

    #+BEGIN_SRC c
      regexp3( "linea simple", "^linea" );
    #+END_SRC

  - busqueda posicional al final 'exp$'

    #+BEGIN_SRC c
      regexp3( "linea simple", "simple$" );
    #+END_SRC

  - busqueda posicional al inicio y final "^exp$"

    #+BEGIN_SRC c
      regexp3( "linea simple", "^linea simple$" );
    #+END_SRC

    - NOTA :: Los caracteres de busqueda posicional solo tienen efecto
              al colocarse al incio o final del patron de busqueda,
              colocar estos caracteres en cualquier otra posicion,
              agrega dicho caracter *tal cual* detro del patron de
              busqueda, es decir no tiene ningun siginificado
              especial.


  - opciones de busqueda multiples "exp1|exp2"

    #+BEGIN_SRC c
      regexp3( "Handel", "Handel|Haendel|Dinosaurio" );
    #+END_SRC

  - Rango de caracteres "x-n"

    #+BEGIN_SRC c
      regexp3( "Handel", "Ha-zndel" );
    #+END_SRC

    - NOTA :: Los rangos de caracteres pueden colocarse dentro de
              texto simple, una agrupacion o agrupacion con captura y
              dentro de un Conjunto de caracteres.

  - Conjunto de caracteres "[abc]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[eioau]ndel" );
    #+END_SRC

    - NOTA :: Dentro de un conjunto de caracteres los siguientes
              caracteres carecen de significado especial =[|)}= y
              pueden incluire tal cual si necesidad de escapar el
              caracter.

      #+BEGIN_SRC c
        regexp3( "$|)}^", "([$|)}^])+" );
      #+END_SRC


  - Rango(s) dentro de conjunto de caracteres "[x-n]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[1-9a-z]ndel" );
    #+END_SRC

  - inversion de conjunto de caracteres  "[^abc]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[^eiou]ndel" );
    #+END_SRC

  - coincidencia con cualquier caracter '.'

    #+BEGIN_SRC c
      regexp3( "Handel", "H.ndel" );
    #+END_SRC

  - coincidencia cero o una ves '?'

    #+BEGIN_SRC c
      regexp3( "Hndel", "Ha?ndel" );
    #+END_SRC

  - coincidencia una o mas veces '+'

    #+BEGIN_SRC c
      regexp3( "Haaandel", "Ha+ndel" );
    #+END_SRC

  - coincidencia cero o mas veces '*'

    #+BEGIN_SRC c
      regexp3( "Handel", "Hae*ndel" );
    #+END_SRC

  - rango de coincidencias '{n1,n2}'

    #+BEGIN_SRC c
      regexp3( "Haandel", "Ha{1,100}ndel" );
    #+END_SRC

  - numero de coincidencia especifico '{n1}'

    #+BEGIN_SRC c
      regexp3( "Haandel", "Ha{2}ndel" );
    #+END_SRC

  - caracter ascii en notacion octal "\ooo"

    #+BEGIN_SRC c
      regexp3( "Handel", "H\141andel" );
    #+END_SRC

  - caracter ascii en notacion hexadecimal "\xhh"

    #+BEGIN_SRC c
      regexp3( "Handel", "H\x61andel" );
    #+END_SRC

  - caracter unicode "\uhhhh"

    #+BEGIN_SRC c
      regexp3( "Haéndel", "Ha\u00E9ndel" );
    #+END_SRC

    - NOTA :: Aparentemente en entornos *nix, el manejo de caracteres
              unicode no requiere consideraciones extra, a diferencia
              de otros sistemas operativos para aficionados donde se
              requiere utilizar =wmain=, =wchar=, =wprintf=,
              =w*$$@&!=... en caso de utilizar un sistema con dicha
              "caracteristica", es recomendable erradicar cualquier
              rastro del SO en cuestion y recorrer el verdadero camino
              del programador, prueba a con Debian GNU/linux o algun
              BSD.

    - NOTA :: La forma de procesar caracteres unicode o con notacion
              hexadecimal es misteriosa y se desconocen los metodos
              automagicos internos sobre como maneja el compilador
              dicha notacion, sea precavido al utilizar caracteres mas
              alla del simple y buen ascii.


  - escape de caracter con significado especial "\\c"

    los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*',
    '{', '}', '-' y '\' indican como debe procesarse la exprecion regular,
    colocar alguno de estos caracteres tal cual, sin tener en cuenta
    una correcta sintaxis dentro de la exprecion, puede generar bucles
    infinitos al igual que errores por violacion de segmento.

    anteceder cualquier caracter (excluyendo cadenas de escape propias
    de C) con doble diagonal =\=, elimina el significado especial y
    permite buscar tal cual el caracter.

    #+BEGIN_SRC c
      regexp3( "|()<>[]?+*{}-\\", "<\\|\\(\\)\\<\\>\\[\\]\\?\\+\\*\\{\\}\\-\\\\>" );
    #+END_SRC

  - agrupacion "(exp)"

    #+BEGIN_SRC c
      regexp3( "Handel", "(Handel)" );
    #+END_SRC

  - agrupacion con captura "<exp>"

    #+BEGIN_SRC c
      regexp3( "Handel", "<Handel>" );
    #+END_SRC

** Recuperacion de captura

   Cualquier agrupacion "<exp>" exitosa, genera una captura del texto
   localizado, dichas capturas se almacenan segun el orden de
   aparicion y posicion dentro de la agrupacion por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion dentro de la agrupacion es capturada mas de una vez
   dentro de la linea de busqueda el indice, se incrementa segun su
   aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     primer captura               segunda captura      tercer captura
   #+END_EXAMPLE

   para recuperar una captura se hace uso de la funcion =getCatch=,
   aqui su prototipo:

   #+BEGIN_SRC c
     char * getCatch( char * lineCatch, int index )
   #+END_SRC

   - lineCatch :: puntero lo suficientemete grande para contener la
                  captura.

   - index     :: indice de agrupacion a recuperar de =1= a =n=.



   la funcion regeresa un apuntador a la captura terminada en '\0'. Un
   indice incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero de agrupaciones capturadas utlice
   =indexCatch=:

   #+BEGIN_SRC c
     int indexCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=. Podria utilzar esta y la
   anterior funcion para imprimir las agrupaciones capturadas con una
   funcion como:

   #+BEGIN_SRC c
     void printCatch(){
       char lineCatch[128];
       int i = 0, max = indexCatch();

       while( ++i <= max )
         printf( "#%d# >%s<\n", i, getCatch( lineCatch, i ) );
     }
   #+END_SRC

** Reemplazo de captura

   El reemplazo opera sobre un arreglo de caracteres en el cual se
   coloca la linea de busqueda con las capturas reemplazadas, la
   funcion encargada de esta labor es =replaceCatch=, su prototipo es:

   #+BEGIN_SRC c
     char * replaceCatch( char * newLine, char * str, int index );
   #+END_SRC

   - newLine :: arreglo de caracteres lo suficientemente grande para
                contener la linea sobre la que se efectua la busqueda,
                tomando en cuenta el numero y dimencion de capturas a
                reemplazar.

   - str     :: cadena de caracteres con la cual reemplazar la
                captura.

   - index   :: indice de captura segun el orden de aparicion dentro
                de la exprecion regular. Pasar un indice incorrecto,
                coloca una copia sin modificacion de la cadena de
                busqueda sobre el arreglo =newLine=.


   en este caso el uso del argumento =index= a diferencia de la
   funcion =getCatch= no se refiere a una "captura" en especifico,
   es decir no importa la cantidad de ocaciones que se ha capturado
   una exprecion, el indice indica la *posicion* dentro de la
   exprecion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
     exprecion de agrupacion con captura
   #+END_EXAMPLE

   modifica una o varias capturas como

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
     = 1 ==================       = 1 ==================      = 1 ==================
         = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
     modificacion en captura uno  "..." dos                   "..." tres
   #+END_EXAMPLE

** Metacaracteres de busqueda

   - \\ : diagonal
   - \a : "campana"
   - \e : "Esc"
   - \f : salto de página
   - \n : "nueva línea"
   - \r : "retorno de carro"
   - \t : tabulador.
   - \v : tabulador vertical
   - \x : exadecimal  8 bits 00-ff
   - \u : exadecimal 16 bits 0000-FFFF


   - NOTA :: los anteriores caracteres estan por defecto incluidos en
             c, no fue necesario implementarlos.


   - \\d : dígito del 0 al 9.
   - \\D : cualquier carácter que no sea un dígito del 0 al 9.
   - \\w : cualquier carácter alfanumérico.
   - \\W : cualquier carácter no alfanumérico.
   - \\s : espacio en blanco.
   - \\S : cualquier carácter que no sea un espacio en blanco.


   - NOTA :: los anteriores (y siguietes) caracteres requieren doble
             '\\' para escapar '\'


   - \\| : barra vertical
   - \\^ : acento circunflejo
   - \\$ : signo dolar
   - \\( : parentesis izquierdo
   - \\) : parentesis derecho
   - \\< : mayor que
   - \\> : menor que
   - \\[ : corchete izquierdo
   - \\] : corchete derecho
   - \\. : punto
   - \\? : interrogacion
   - \\+ : mas
   - \\- : menos
   - \\* : asterisco
   - \\{ : llave izquierda
   - \\} : llave derecha


   - NOTA :: los anteriores caracteres insertan un caracter con
             significado especial para su busqueda dentro de la
             cadena, incluir el caracter tal cual (sin doble escape
             '\\') en cualquier lugar es erroneo por ejemplo:

             #+BEGIN_EXAMPLE
               "(agrupacion[erronea)"
             #+END_EXAMPLE

             en lugar de

             #+BEGIN_EXAMPLE
               "(agrupacion\\[correcta)"
             #+END_EXAMPLE

             puede generar un error durante el analisis de la cadena
             de busqueda y provocar un ciclo infinito y/o otros
             sucesos apocalipticos.

** ejemplos interesantes de busqueda

   #+BEGIN_SRC c
      regexp3( "▞▞▞▞aaaa1aaa", "((\u259e?){3,100}(\\D)*(\\d?)\\w+)*" );
   #+END_SRC

   busqueda y captura de tres o mas caracteres unicode '▞' que pueden
   estar o no presentes, seguido por cero o mas caracteres que no son
   numero, seguido por uno o ningun digito, seguido por uno a mas
   caracteres, todo buscado cero o mas veces

   #+BEGIN_SRC c
      regexp3( "1999-12-05", "((\\d){2,4}(\\-|/)(\\d)*(\\W{1})(\\d+))" );
   #+END_SRC

   captura algo parecido a una fecha (cifras y separadores) separado
   por '-' o '/' y un caracter no alfanumerico

   #+BEGIN_SRC c
      regexp3( "<a href=\"https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular\">", "((https?://)([^\"])*)" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "contacto (nasciiboy@gmail.com) $$", "(\\w+@\\w+\\.\\w+)" );
   #+END_SRC

   capturar algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?(\\d{4})\\D?" );
   #+END_SRC

   capturar primer cifra parecida a un año

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?(\\d{4})\\D?$" );
   #+END_SRC

   captura ultima cifra parecida a un año

   #+BEGIN_SRC c
      regexp3( "linea86\nlinea87", "no|41|(di|no|saurio|((s|a|l)+i*ne(a[^\\D]{2}))\n?)+" );
   #+END_SRC

   expresion inecesariamente compleja para capturar "lineaxx" u otras
   cosas

* Hacking

  Cual es el algoritmo para resolver una estructura regular?

  1. Dividir la expresion en sus rutas principales.

     Las rutas se marcan mediante el signo '|' que indica multiples
     opciones a seguir.

     #+BEGIN_EXAMPLE
       ruta uno | ruta dos | ruta n
     #+END_EXAMPLE

     La posicion de cada expresion es indicativa del orden en que debe
     resolverse. Una ruta principal se encuentra en el nivel de
     anidamiento *cero* es decir no esta agrupada dentro de otra
     exprecion.

     #+BEGIN_EXAMPLE
       (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       = 0 ================================================
       = 1 ======   = 1 ==========================
                      = 2 ======================
     #+END_EXAMPLE

     un nuevo nivel de anidamiento surge utilizando '(' y finaliza con
     ')'. Cada '(' aumenta el anidamiento en 1 y cada ')' lo
     disminulle en 1, si encontramas '|' al tener anidamiento 0, hemos
     encontrado una ruta principal.

     =walker= es la funcion que recursivamente optiene las rutas
     pricipales, pasa cada posible ruta en orden a si misma y la
     almacena en la variable local =track=, cada nueva y ultima ruta
     principal no es divible y es enviada a =trekking= (senderista)
     que debe dividirla en expreciones mas sencillas.

     #+BEGIN_EXAMPLE
       walker 1 # (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       walker 2 # (ruta uno)
       walker 3 #              ( (ruta dos a | rutad dos b) )
       walker 1 #                                               ruta n
     #+END_EXAMPLE

  2. Una ruta principal debe descomponerse en senderos o trayectos mas
     sencillos eliminando niveles de anidamiento y obteniendo nuevas
     rutas hasta dejar cadenas que puedan compararse caracter a
     caracter.

     La funcion =trekking= envia lo que internamente considera una
     ruta a la funcion =tracker=, la cual corta y marca trayectos
     segun el contexto.

     #+BEGIN_EXAMPLE
       trekking 1 # (ruta uno)
       tracker       ruta uno
     #+END_EXAMPLE

     en este punto cada nuevo track es evaluado en busca de signos que
     indiquen la necesidad de seguir reduciendo la exprecion
     (=isPath=) en rutas, metacaracteres, clases de caracteres,
     rangos, y repeticiones. De ser esto necesario se enviara el
     trayecto a =walker= para crear un nuevo ciclo de analicis. De lo
     contrario el =track= es comparable directamente y se optiene un
     resultado que es enviado a =walker= quien responde a =regexp3=.

     Cuando se requiere una nueva reduccion se envia una copia del
     =track= a =walker= quien inicia una vez mas todo el proceso
     anterior hasta optener un resultado por parte de =trekking=.

  3. optener el numero de ciclos de repeticion para cada
     ruta/trayecto/expresion

     una vez que =tracker= a reducido una ruta a trayecto, envia dicho
     trayecto a =setLoops= quien dependiento lo que encuentre a
     continuacion establece el numero de repeticiones en la variable
     =LoopRange= (miembro de la estructura =Path=).

     #+BEGIN_EXAMPLE
       trekking  a-z    texto     (ruta uno)  *c       ?[abc]     {2,3}
       tracker   a-z    | texto   | ruta uno  | c      | abc
       tipo      RANGEAB| SIMPLE  | HOOK      | SIMPLE | BRACKET
       continua  t      | (       | *         | ?      | {
       setLoops  1-1    | 1-1     | 0-INF     | 0-1    | 2-3
       continua  t      | (       | c         | [      | '\0'
     #+END_EXAMPLE

     si la exprecion siguiente es siginificativa =setLoops= corta y
     establece una nueva posicion al fin de dicha exprecion.


  El siguiente diagrama ofrece una vision aproximada del
  funcionamiento del programa.

  file:regexp3.jpg

** Macros

   #+BEGIN_SRC c
     #define TRUE      1
     #define FALSE     0
     #define INF    1024
     #define CATCHS   24
   #+END_SRC

   =INF= establece el numero maximo de ciclos de repeticion para cada
   =track=.

   =CATCHS= establece la cantidad de capturas maximas detro de cada
   busqueda.

** Estructuras y enumeracines

   #+BEGIN_SRC c
     struct PathLine {
       char *line;
       int   pos;
       int   len;
     };
   #+END_SRC

   =line= apunta al inicio de la cadena sobre la que se efectua la
   busqueda, =pos= marca la posicion actual sobre la que se encuentra
   la busqueda y =len= contiene la longitud de la cadena.

   #+BEGIN_SRC c
     struct LoopsRange {
       int a, b;
     };

     enum PTYPE { PATH, HOOK, SIMPLE, BRACKET, RANGEAB, META, POINT };

     struct Path {
       int   len;
       char *ptr;
       enum   PTYPE type;
       struct LoopsRange loopsRange;
     };
   #+END_SRC

   =Path= contiene la exprecion regular, deacuerdo a cada funcion
   puede ser llamada =path=, =track= o =text= para indicar si se trata
   de la ruta principal, un divicion de esta, o texto para una
   comparacion directa.

   =ptr= y =len= indican el inicio y longitud de la exprecion.

   =type= indica el tipo.

   - =PATH= ruta principal.
   - =HOOK= agrupacion.
   - =SIMPLE= texto simple directamente comparable.
   - =BRACKET= clase de caracteres
   - =RANGEAB= rango de caracteres.
   - =META= metacaracter.
   - =POINT= punto.


   #+BEGIN_SRC c
     struct CATch {
       char *ptr[CATCHS];
       int   len[CATCHS];
       int   id [CATCHS];
       int   idx;
       int   index;
     } Catch;
   #+END_SRC

   =Catch= almacena un arreglo de apuntadores (=ptr=) al inicio de
   cada captura y su longitud =len=. =index= indica el numero total de
   capturas.

   =id= identifica el orden de aparicion dentro de la exprecion
   regular, =idx= es una variable auxiliar para obtener el
   identificador.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y
  acorde a ello se utiliza la licencia GNU GPL Version 3. Cualquier
  obra que incluya o derive codigo de esta libreria, debera cumplir
  con los terminos de esta licencia.

* Contacto, contribucion, patrocinio, ofrecimientos y otras cosas

  [[mailto:nasciiboy@gmail.com]]
