#+TITLE: Recursive Regexp Raptor (regexp3)
#+AUTHOR: nasciiboy
#+LANGUAGE: es
#+STARTUP: showall
#+OPTIONS: H:5 num:nil html-postamble:nil html-style:nil html-scripts:nil

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda y captura de
  expresiones regulares escrita en C, siguiendo (/buscando/) los
  siguientes lineamientos:

  - Cumplir con la mayoria de funciones esperadas por una libreria de
    este tipo.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar peticion explicita de memoria dinamica.

  - Ser util como material de aprendizaje.

** Motivacion

   Partiendo de que C no dispone de una libreria estandar de
   expresiones regulares, el autor se planteo la busqueda de una
   alternativa funcional de la cual aprender un poco, GNU tiene tanto
   gawk como una libreria regexp, sin embargo el autor de este trabajo
   (que igual y es un poco retard) encontro en ambas codigo rebuscado
   y mistico repartido en varios ficheros, llenos de macros y
   variables cripticas. La siguiente opcion fue [[https://github.com/cesanta/slre][slre]] donde se encontro
   un codigo mas compacto aunque no menos rebuscado, con un diseño
   poco claro que ademas fallaba si existia un nivel de anidamiento
   siguiente al previo es decir:

   #+BEGIN_EXAMPLE
     (((a|b)))((x|b))
     = 1 =====
              = 2 === ERROR
   #+END_EXAMPLE

   asi que tras un retiro a la isla de la meditacion onanista se
   propuso hacer su propia libreria con casinos y colegialas
   japonesas.

** Desarrollo y pruebas

   Se ha echo uso del "editor" GNU Emacs y el compilador gcc version
   5.3.1, corriendo en fedora 23. Aparentemente en entornos *Nix, el
   manejo de caracteres unicode no requiere consideraciones extra, a
   diferencia de otros sistemas operativos menos serios donde hace
   falta utilizar wmain, wchar, wprintf, w*$$@&!...

   El autor recomienda el uso de sistemas y herramientas serias.

   para compilar solo hace falta un

   #+BEGIN_SRC sh
     gcc test.c regexp3.c
   #+END_SRC

   para la ejecucion basta un confiable

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  La unica funcion de busqueda es =regep3= aqui su prototipo:

  #+BEGIN_SRC c
    int regexp3( char *line, char *exp );
  #+END_SRC

  - line :: apuntador a cadena sobre la que efectuar la busqueda, debe
            finalizar con el signo de terminacion '\0'.

  - exp  :: apuntador a cadena que contiene la expresion regular de
            busqueda, debe finalizar con el signo de terminacion '\0'.


  La funcion retorna =1= en caso de localizar la expresion dentro de
  la cadena de busqueda. Regresa =0= en caso contrario.

  Se disponen de la mayoria de funciones habituales

  - busqueda de texto simple en cualquier lugar de una linea:

    #+BEGIN_SRC c
      regexp3( "linea simple", "a s" );
    #+END_SRC

  - busqueda posicional al inicio '^'

    #+BEGIN_SRC c
      regexp3( "linea simple", "^linea" );
    #+END_SRC

  - busqueda posicional al final '$'

    #+BEGIN_SRC c
      regexp3( "linea simple", "simple$" );
    #+END_SRC

  - busqueda posicional al inicio y final "^exp$"

    #+BEGIN_SRC c
      regexp3( "linea simple", "^linea simple$" );
    #+END_SRC

    - ADVERTENCIA ::

         la busqueda posicional *solo* puede incluirse al inicio y
         final del patron de busqueda (=exp=), incluir estos
         caracteres en cualquier otra posicion (excluyendo "clases de
         caracteres") es un error, para incluirlos como simples
         caracteres antecedalos por doble diagonal "\\^" o "\\$".


  - opciones de busqueda multiples "exp|exp"

    #+BEGIN_SRC c
      regexp3( "Handel", "Handel|Haendel|Dinosaurio" );
    #+END_SRC

  - Rango de caracteres "x-n"

    #+BEGIN_SRC c
      regexp3( "Handel", "Ha-zndel" );
    #+END_SRC

  - Clases de caracteres "[abc]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[eioau]ndel" );
    #+END_SRC

    =[$|)}^= solo estos meta caracteres pueden buscarse dentro de una
    clase de caracteres sin agregar escape, considere la posicion de
    '^' para evitar la inversion.

    #+BEGIN_SRC c
      regexp3( "$|)}^", "([$|)}^])+" );
    #+END_SRC

  - Rango(s) dentro de Clases de caracteres "[x-n]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[1-9a-z]ndel" );
    #+END_SRC

  - inversion de Clases de caracteres  "[^abc]"

    #+BEGIN_SRC c
      regexp3( "Handel", "H[^eiou]ndel" );
    #+END_SRC

  - coincidencia con cualquier caracter '.'

    #+BEGIN_SRC c
      regexp3( "Handel", "H.ndel" );
    #+END_SRC

  - coincidencia cero o una ves '?'

    #+BEGIN_SRC c
      regexp3( "Hndel", "Ha?ndel" );
    #+END_SRC

  - coincidencia una o mas veces '+'

    #+BEGIN_SRC c
      regexp3( "Haaandel", "Ha+ndel" );
    #+END_SRC

  - coincidencia cero o mas veces '*'

    #+BEGIN_SRC c
      regexp3( "Handel", "Hae*ndel" );
    #+END_SRC

  - rango de coincidencias '{n1,n2}'

    #+BEGIN_SRC c
      regexp3( "Haandel", "Ha{1,100}ndel" );
    #+END_SRC

  - numero de coincidencias especifico '{n1}'

    #+BEGIN_SRC c
      regexp3( "Haandel", "Ha{2}ndel" );
    #+END_SRC

  - agrupacion y captura "(exp)"

    #+BEGIN_SRC c
      regexp3( "Handel", "(Handel)" );
    #+END_SRC

** Recuperacion de captura

   Cualquier agrupacion exitosa, genera una captura del texto
   localizado, dichas capturas se almacenan segun el orden de
   aparicion y posicion dentro del agrupamiento por ejemplo:

   #+BEGIN_EXAMPLE
     (   (   )  | (   (   )   )   )
     = 1 ==========================
         = 2==
                  = 2 =========
                      = 3 =
   #+END_EXAMPLE

   para recuperar una captura se hace uso de la funcion =getCatch=,
   aqui su prototipo:

   #+BEGIN_SRC c
     char * getCatch( char * lineCatch, int index )
   #+END_SRC

   - lineCatch :: puntero lo suficientemete grande para contener la
                  agrupacion.

   - index     :: indice de agrupacion a recuperar de =1= a =n=.


   la funcion regeresa un apuntador a la captura terminada en '\0'. Un
   indice incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero de agrupaciones capturadas utlice
   =CatchIndex=:

   #+BEGIN_SRC c
     int CatchIndex();
   #+END_SRC

   que regresa un valor de =0= a =n=. Podria utilzar esta y la
   anterior funcion para imprimir las agrupaciones capturadas con una
   funcion como:

   #+BEGIN_SRC c
     char lineCatch[128];
     void printCatch(){
       int i = 0, max = CatchIndex();

       while( ++i <= max )
         printf( "#%d# >%s<\n", i, getCatch( lineCatch, i ) );
     }
   #+END_SRC

** Metacaracteres de busqueda

   - \\ : diagonal
   - \a : "campana"
   - \e : "Esc"
   - \f : salto de página
   - \n : "nueva línea"
   - \r : "retorno de carro"
   - \t : tabulador.
   - \v : tabulador vertical
   - \x : exadecimal  8 bits 00-ff
   - \u : exadecimal 16 bits 0000-FFFF


   - NOTA :: los anteriores caracteres estan por defecto incluidos en
             c, no fue necesario implementarlos.


   - \\d : dígito del 0 al 9.
   - \\D : cualquier carácter que no sea un dígito del 0 al 9.
   - \\w : cualquier carácter alfanumérico.
   - \\W : cualquier carácter no alfanumérico.
   - \\s : espacio en blanco.
   - \\S : cualquier carácter que no sea un espacio en blanco.


   - NOTA :: los anteriores (y siguietes) caracteres requieren doble
             '\\' para escapar '\' y dar significado de meta caracter.


   - \\| : barra vertical
   - \\^ : acento circunflejo
   - \\$ : signo dolar
   - \\( : parentesis izquierdo
   - \\) : parentesis derecho
   - \\[ : corchete izquierdo
   - \\] : corchete derecho
   - \\. : punto
   - \\? : interrogacion
   - \\+ : mas
   - \\- : menos
   - \\* : asterisco
   - \\{ : llave izquierda
   - \\} : llave derecha


   - NOTA :: los anteriores caracteres insertan un caracter con
             significado especial para su busqueda dentro de la
             cadena, incluir el caracter tal cual (sin doble escape
             '\\') en cualquier lugar es erroneo por ejemplo:

             #+BEGIN_EXAMPLE
               "(agrupacion[erronea)"
             #+END_EXAMPLE

             en lugar de

             #+BEGIN_EXAMPLE
               "(agrupacion\\[correcta)"
             #+END_EXAMPLE

             puede generar un error durante el analicis de la cadena
             de busqueda y probocar un ciclo infinito y/o otros
             sucesos apocalipticos.

** ejemplos interesantes de busqueda

   #+BEGIN_SRC c
      regexp3( "▞▞▞▞aaaa1aaa", "((\u259e?){3,100}(\\D)*(\\d?)\\w+)*" );
   #+END_SRC

   busqueda y captura de tres o mas caracteres unicode '▞' que pueden
   estar o no presentes, seguido por cero o mas caracteres que no son
   numero, seguido por uno o ningun digito, seguido por uno a mas
   caracteres, todo buscado cero o mas veces

   #+BEGIN_SRC c
      regexp3( "1999-12-05", "((\\d){2,4}(\\-|/)(\\d)*(\\W{1})(\\d+))" );
   #+END_SRC

   captura algo parecido a una fecha (cifras y separadores) separado
   por '-' o '/' y un caracter no alfanumerico

   #+BEGIN_SRC c
      regexp3( "<a href=\"https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular\">", "((https?://)([^\"])*)" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "contacto (nasciiboy@gmail.com) $$", "(\\w+@\\w+\\.\\w+)" );
   #+END_SRC

   capturar algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?(\\d{4})\\D?" );
   #+END_SRC

   capturar primer cifra parecida a un año

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?(\\d{4})\\D?$" );
   #+END_SRC

   captura ultima cifra parecida a un año

   #+BEGIN_SRC c
      regexp3( "linea86\nlinea87", "no|41|(di|no|saurio|((s|a|l)+i*ne(a[^\\D]{2}))\n?)+" );
   #+END_SRC

   expresion inecesariamente compleja para capturar "lineaxx" u otras
   cosas

* Hacking

  Cual es el algoritmo para resolver una estructura regular?

  1. Dividir la expresion en sus rutas principales.

     Las rutas se marcan mediante el signo '|' que indica multiples
     opciones a seguir.

     #+BEGIN_EXAMPLE
       ruta uno | ruta dos | ruta n
     #+END_EXAMPLE

     La posicion de cada expresion es indicativa del orden en que debe
     resolverse. Una ruta principal se encuentra en el nivel de
     anidamiento *cero* es decir no esta agrupada dentro de otra
     exprecion.

     #+BEGIN_EXAMPLE
       (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       = 0 ================================================
       = 1 ======   = 1 ==========================
                      = 2 ======================
     #+END_EXAMPLE

     un nuevo nivel de anidamiento surge utilizando '(' y finaliza con
     ')'. Cada '(' aumenta el anidamiento en 1 y cada ')' lo
     disminulle en 1, si encontramas '|' al tener anidamiento 0, hemos
     encontrado una ruta principal.

     =walker= es la funcion que recursivamente optiene las rutas
     pricipales, pasa cada posible ruta en orden a si misma y la
     almacena en la variable local =track=, cada nueva y ultima ruta
     principal no es divible y es enviada a =trekking= (senderista)
     que debe dividirla en expreciones mas sencillas.

     #+BEGIN_EXAMPLE
       walker 1 # (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       walker 2 # (ruta uno)
       walker 3 #              ( (ruta dos a | rutad dos b) )
       walker 1 #                                               ruta n
     #+END_EXAMPLE

  2. Una ruta principal debe descomponerse en senderos o trayectos mas
     sencillos eliminando niveles de anidamiento y obteniendo nuevas
     rutas hasta dejar cadenas que puedan compararse caracter a
     caracter.

     La funcion =trekking= envia lo que internamente considera una
     ruta a la funcion =tracker=, la cual corta y marca trayectos
     segun el contexto.

     #+BEGIN_EXAMPLE
       trekking 1 # (ruta uno)
       tracker       ruta uno
     #+END_EXAMPLE

     en este punto cada nuevo track es evaluado en busca de signos que
     indiquen la necesidad de seguir reduciendo la exprecion
     (=isPath=) en rutas, metacaracteres, clases de caracteres,
     rangos, y repeticiones. De ser esto necesario se enviara el
     trayecto a =walker= para crear un nuevo ciclo de analicis. De lo
     contrario el =track= es comparable directamente y se optiene un
     resultado que es enviado a =walker= quien responde a =regexp3=.

     Cuando se requiere una nueva reduccion la respuesta se optiene
     por =walker= quien inicia todo el proceso anterior hasta que
     algun =trekking= responde positiva o negativamente.

  3. optener el numero de ciclos de repeticion para cada
     ruta/trayecto/expresion

     una vez que =tracker= a reducido una ruta a trayecto, envia dicho
     trayecto a =setLoops= quien dependiento lo que encuentre a
     continuacion establece el numero de repeticiones en la variable
     =LoopRange= (miembro de =Path=).

     #+BEGIN_EXAMPLE
       trekking  a-z    texto     (ruta uno)  *c       ?[abc]     {2,3}
       tracker   a-z    | texto   | ruta uno  | c      | abc
       tipo      RANGEAB| SIMPLE  | HOOK      | SIMPLE | BRACKET
       continua  t      | (       | *         | ?      | {
       setLoops  1-1    | 1-1     | 0-INF     | 0-1    | 2-3
       continua  t      | (       | c         | [      | '\0'
     #+END_EXAMPLE

     si la exprecion siguiente es siginificativa =setLoops= corta y
     establece una nueva posicion al fin de dicha exprecion.


  El siguiente diagrama ofrece una vision aproximada del
  funcionamiento del programa.

  file:regexp3.jpg

** Macros

   #+BEGIN_SRC c
     #define TRUE      1
     #define FALSE     0
     #define INF    1024
     #define CATCHS   24
   #+END_SRC

   =INF= establece el numero maximo de ciclos de repeticion para cada
   =track=.

   =CATCHS= establece la cantidad de capturas maximas detro de cada
   busqueda.

** Estructuras y enumeracines

   #+BEGIN_SRC c
     struct PathLine {
       char *line;
       int   pos;
       int   len;
     };
   #+END_SRC

   =line= apunta al inicio de la cadena sobre la que se efectua la
   busqueda, =pos= marca la posicion actual sobre la que se encuentra
   la busqueda y =len= contiene la longitud de la cadena.

   #+BEGIN_SRC c
     struct LoopsRange {
       int a, b;
     };

     enum PTYPE { PATH, HOOK, SIMPLE, BRACKET, RANGEAB, META, POINT };

     struct Path {
       int   len;
       char *ptr;
       enum   PTYPE type;
       struct LoopsRange loopsRange;
     };
   #+END_SRC

   =Path= contiene la exprecion regular, deacuerdo a cada funcion
   puede ser llamada =path= o =track= para indicar si se trata de la
   ruta principal o un divicion de esta.

   =ptr= y =len= indican el inicio y longitud de la exprecion.

   =type= indica el tipo.

   - =PATH= ruta principal.
   - =HOOK= agrupacion.
   - =SIMPLE= texto simple directamente comparable.
   - =BRACKET= clase de caracteres
   - =RANGEAB= rango de caracteres.
   - =META= metacaracter.
   - =POINT= punto.


   #+BEGIN_SRC c
     struct CATch {
       char *ptr[CATCHS];
       int   len[CATCHS];
       int   index;
     } Catch;
   #+END_SRC

   =Catch= almacena un arreglo de apuntadores (=ptr=) al inicio de
   cada captura y su longitud =len=. =index= indica el numero total de
   capturas.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
