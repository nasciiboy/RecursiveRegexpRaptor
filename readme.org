#+TITLE:    Recursive Regexp Raptor (regexp3)
#+AUTHOR:   nasciiboy
#+LANGUAGE: es
#+STARTUP:  showall


* Caracteristicas

  - Manejo sencillo,

  - Sin verificacion de errores en la exprecion resivida. C no es asi.

  - Numero de rutas y agrupamientos limitado solo por la capacidad del
    sistema/hardware

  - El codigo mas compacto y claro que alla precenciado nunca antes
    alguna libreria regexp humana.

  - Cero dependencias. Ni la libreria estandar de C esta
    precente *C PURO*.

  - Soporte UTF8 (2-6 bytes) (experimental)

  - Manejo no explicito de memoria dinamica. No encontrara ningun
    =malloc=, =calloc=, =free=, ...

  - Recuperacion de capturas de forma individual

  - Reemplazo de capturas

  - Creacion de una nueva linea agregando capturas

  - Negacion de expreciones (experimental)

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y
  reemplazo de expresiones regulares escrita en lenguaje C, buscando
  lo siguiente:

  - Cumplir con la mayoria de funciones esperadas por una libreria de
    este tipo.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar peticion explicita de memoria dinamica.

  - Ser util como material de aprendizaje.

** Motivacion

   Partiendo de que C no dispone de una libreria estandar de
   expresiones regulares, se planteo la busqueda de una opcion
   funcional de la cual aprender un poco, GNU tiene tanto gawk como la
   libreria regexp, sin embargo el autor de este trabajo (que igual y
   es un poco retard) encontro en ambas codigo rebuscado y mistico
   repartido en varios ficheros, llenos de macros y variables
   cripticas.

   La siguiente opcion fue la libreria [[https://github.com/cesanta/slre][slre]] cuya principal
   cararacteristica es tener codigo compacto, aunque no mas claro,
   luego de algunos dias descifrando el codigo se descubrio que el
   algoritmo utilizado no era general, cuando la exprecion tenia mas
   de un bloque de anidamiento el resultado siempre es incorrecto es
   decir:

   #+BEGIN_EXAMPLE
     (((a|b)))((x|b))
     = 1 =====        OK
              = 2 === ERROR
   #+END_EXAMPLE

   desepcionado y tras un retiro a la isla de la meditacion onanista
   el autor se propuso hacer su propia libreria con casinos y
   colegialas japonesas.

** Desarrollo y pruebas

   Se ha echo uso del "editor" GNU Emacs y el compilador gcc version
   5.3.1, corriendo en fedora 23.

   para compilar solo hace falta

   #+BEGIN_SRC sh
     gcc test.c regexp3.c
   #+END_SRC

   para la ejecucion basta un confiable

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  Para incluir Recursive Regexp Raptor en su codigo necesita colocar
  los ficheros =regexp3.c=, =regexp3.h= y =charUtils.h= dentro de la
  carpeta de su proyecto. Luego incluir el encabezado

  #+BEGIN_SRC c
    #include "regexp3.h"
  #+END_SRC

  donde desee utilizar la libreria, y finalmente agregar =regexp3.c=
  al comando de compilacion

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3.c
  #+END_SRC

  La unica funcion de busqueda es =regexp3= aqui su prototipo:

  #+BEGIN_SRC c
    int regexp3( char *txt, char *re );
  #+END_SRC

  - txt  :: apuntador a cadena sobre la que efectuar la busqueda, debe
            finalizar con el signo de terminacion '\0'.

  - re   :: apuntador a cadena que contiene la expresion regular de
            busqueda, debe finalizar con el signo de terminacion '\0'.


  La funcion regresa el numero de coincidencias localizadas dentro del
  argumento =txt= es decir de =0= (ninguna) a =n= coincidencias.

  Recursive Regexp Raptor, varia levemente en la forma en como se modifica el
  comportamiento de la expresion, hace uso de /modificadores/, estos
  anteceden a la exprecion o seccion de esta, con la sintaxis

  #+BEGIN_SRC c
    #modificador
  #+END_SRC

  donde '#' indica la modificacion del comportamiento y "modificador" es uno
  o una combinacion de cuatro signos '^', '$', '?' y '!', los primeros 3
  afectan de forma /global/ a la expresion y solo tienen efecto si el
  modificador antecede cualquier exprecion como en:

  #+BEGIN_SRC c
    regexp3( "Raptor Test", "#^$Raptor Test" );
    //                       ^
    //                       |
    //  MODIFICADOR GLOBAL  -+ ANTECEDE CUALQUIER EXPRESION
    //  los modificaders son  ^$
    //  la seccion de busqueda  Raptor Test
  #+END_SRC

  el modificador '!' indica «mientras la expresion no coincida con el siguente
  caracter, sigue adelante» de momento es el unico modificador valido en
  secciones de la expresion, quiza se agregen mas en un futuro, por ejemplo
  para ignorar entre mayusculas o minusculas y demas, por ahora no ha sido
  necesario. otro ejemplo para ilustrar el uso de modificadores

  #+BEGIN_SRC c
    regexp3( "Raptor Test", "#^Raptor #!Fest" );
    //                       ^
    //                       |
    //  MODIFICADOR GLOBAL  -+
    //  el modificador es     ^
    //  primer seccion        >Raptor <
    //  segunda seccion              >#!Fest<
    //                                ^
    //                                |
    //  MODIFICADOR DE SECCION  ------+
    //  el modificador es              !
  #+END_SRC

  aqui se dice: de forma global busca algo que inicie con "Raptor " y que no
  continue con la palabra "Fest"

** Caracteristicas soportadas

   - busqueda de texto en cualquier ubicacion:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Raptor" );
     #+END_SRC

   - busqueda posicional al inicio '#^exp'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#^Raptor" );
     #+END_SRC

   - busqueda posicional al final '#$exp'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#$Test" );
     #+END_SRC

   - busqueda posicional al inicio y final "#^$exp"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#^$Raptor Test" );
     #+END_SRC

   - detener con la primer coincidencia "#?exp"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#?Raptor Test" );
     #+END_SRC

   - opciones de busqueda multiples "exp1|exp2"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Dinosaur|T Rex|Raptor|Triceratops" );
     #+END_SRC

   - Rango de caracteres "x-n"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra-zptor" );
     #+END_SRC

     - NOTA :: Los rangos de caracteres pueden colocarse dentro de una
               agrupacion, conjunto de caracteres y texto simple.

     - NOTA :: Solo estan soportados rangos de caracteres ASCII


   - Conjunto de caracteres "[abc]"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R[uoiea]ptor" );
     #+END_SRC

     - NOTA :: Dentro de un conjunto de caracteres los siguientes
               caracteres carecen de significado especial =[|)}= y
               pueden incluire tal cual si necesidad de escapar el
               caracter.

       #+BEGIN_SRC c
         regexp3( "$|)}^", "([$|)}^])+" );
       #+END_SRC


   - Rango(s) dentro de conjunto de caracteres "[x-n]"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R[a-z]ptor" );
     #+END_SRC

   - inversion de conjunto de caracteres  "[^abc]"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R[^uoie]ptor" );
     #+END_SRC

   - *negacion de exprecion* "#!exp"

     El modificador de negacion ha de preceder la exprecion a /negar/ por
     ejemplo si desea negar un conjunto de caracteres

     #+BEGIN_EXAMPLE
       #![abc]
     #+END_EXAMPLE

     para una agrupacion

     #+BEGIN_EXAMPLE
       #!(abc|def)
     #+END_EXAMPLE

     para texto

     #+BEGIN_EXAMPLE
       #!abc
     #+END_EXAMPLE

     combinacion

     #+BEGIN_EXAMPLE
       #!texto#![conjunto]#!(agrupacion)
     #+END_EXAMPLE

   - coincidencia con cualquier caracter '.'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R.ptor" );
     #+END_SRC

   - coincidencia cero o una ves '?'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra?ptor" );
     #+END_SRC

   - coincidencia una o mas veces '+'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra+ptor" );
     #+END_SRC

   - coincidencia cero o mas veces '*'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra*ptor" );
     #+END_SRC

   - rango de coincidencias "{n1,n2}"

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{0,100}ptor" );
     #+END_SRC

   - numero de coincidencia especifico '{n1}'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra{1}ptor" );
     #+END_SRC

   - caracter ascii en notacion octal "\ooo"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R\141ptor" );
     #+END_SRC

   - caracter ascii en notacion hexadecimal "\xhh"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R\x61ptor" );
     #+END_SRC

   - caracter unicode "\uhhhh"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R\u25B3ptor" );
     #+END_SRC

     o

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R△ptor" );
     #+END_SRC

     tambien

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R[△]ptor" );
     #+END_SRC

   - escape de caracter con significado especial "\\c"

     los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*',
     '{', '}', '-' y '\' indican como debe procesarse la exprecion regular,
     colocar alguno de estos caracteres tal cual, sin tener en cuenta
     una correcta sintaxis dentro de la exprecion, puede generar bucles
     infinitos al igual que errores por violacion de segmento.

     anteceder cualquier caracter (excluyendo cadenas de escape propias
     de C) con doble diagonal =\=, elimina (de tener) el significado
     especial y permite buscar tal cual el caracter.

     #+BEGIN_SRC c
       regexp3( "|()<>[]?+*{}-\\", "<\\|\\(\\)\\<\\>\\[\\]\\?\\+\\*\\{\\}\\-\\\\>" );
     #+END_SRC

     o

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "\\R\\a\\p\\t\\o\\r\\ \\T\\es\\t" );
     #+END_SRC

   - agrupacion "(exp)"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "(Raptor)" );
     #+END_SRC

   - agrupacion con captura "<exp>"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "<Raptor>" );
     #+END_SRC

** Comportamiento al recorrer el texto de busqueda

   Al localizar una coincidencia, la nueva busqueda inicia a partir
   del final de dicha coincidencia en lugar del caracter siguiente al
   inicio de la coincidencia. Si desea realizar una busqueda caracter
   a caracter (incluyendo caracteres UTF-8 de longitud variable)
   elimine el fragmento de codigo

   #+BEGIN_SRC c
     hit && hit && text.pos ? text.pos :
   #+END_SRC

   dentro de la funcion =regexp3= en el fichero =regexp3.c=.

   Adicionalmente podria no estar interesado en utilizar la libreria
   con caracteres no ASCII, para obtener una considerable mejora de
   rendimiento serian necesarias algunas modificaciones menores como
   eliminar todo el codigo referente a =UTF=, la funcion =utf8meter=,
   y la constante =xooooooo=, asi como substituir la aparicion de
   =utf8meter= por =1=, =++= o alguna expresion equivalente, donde sea
   necesario.

** Capturas

   Cualquier agrupacion "<exp>" exitosa, genera una captura del texto
   localizado, dichas capturas se almacenan segun el orden de
   aparicion y posicion dentro de la agrupacion por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion dentro de la agrupacion es capturada mas de una vez
   dentro de la linea de busqueda el indice, se incrementa segun su
   aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     primer captura               segunda captura      tercer captura
   #+END_EXAMPLE

   la funcion =cpytCatch= copia la captura dentro de un arreglo de
   caracteres, aqui su prototipo:

   #+BEGIN_SRC c
     char * cpyCatch( char * str, int index )
   #+END_SRC

   - str   :: puntero lo suficientemete grande para contener la captura.

   - index :: indice de agrupacion a recuperar de =1= a =n=.


   la funcion regeresa un apuntador a la captura terminada en '\0'. Un
   indice incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero de agrupaciones capturadas utlice
   =totCatch=:

   #+BEGIN_SRC c
     int totCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=. Podria utilzar esta y la
   anterior funcion para imprimir las agrupaciones capturadas con una
   funcion como:

   #+BEGIN_SRC c
     void printCatch(){
       char str[128];
       int i = 0, max = totCatch();

       while( ++i <= max )
         printf( "[%d] >%s<\n", i, cpyCatch( str, i ) );
     }
   #+END_SRC

*** =gpsCatch()= y =lenCatch()=

    una alternativa a =cpyCatch()=, son las funciones =gpsCatch()= y
    =lenCatch()=. La primera regresa un puntero a la posicion donde
    fue encontrada la captura, la segunda regresa la longitud de la
    captura.

    #+BEGIN_SRC c
      char * gpsCatch( int index );
      int lenCatch   ( int index );
    #+END_SRC

    un ejemplo de uso seria:

    #+BEGIN_SRC c
      void printCatch(){
        int i = 0, max = totCatch();

        while( ++i <= max )
          printf( "[%d] >%.*s<\n", i, lenCatch( i ), gpsCatch( i ) );
      }
    #+END_SRC

*** Colocar capturas dentro de una linea

    #+BEGIN_SRC c
      char * modCatch( char * newTxt, char * mstr );
    #+END_SRC

    el argumento =mStr= contiene el texto con el cual formar la nueva cadena
    asi como indicadores de cuales capturas colocar. El texto se coloca tal
    cual, para indicar la insercion de una captura coque el signo '\' seguido
    del indice de captura:

    #+BEGIN_SRC c
      mStr = "captura 1 >>\\1<< captura 2 >>\\2<< captura 747 >>\\747<<";
    #+END_SRC

    para imprimir el caracter '\' dentro de la nueva cadena escape '\'
    "\\". Dentro de la cadena del programa tendra que colocar los respectivos
    escapes del escape es decir:

    #+BEGIN_CENTER
      cadena = "\\\\Escape\\\\"
    #+END_CENTER

    =newTxt= una apuntador a un arrglo de caracteres del tamaño suficiente
    para almacenar el texto resultante.

*** Reemplazo de captura

    El reemplazo opera sobre un arreglo de caracteres en el cual se
    coloca el texto de busqueda con las capturas reemplazadas, la
    funcion encargada de esta labor es =rplCatch=, su prototipo es:

    #+BEGIN_SRC c
      char * rplCatch( char * newTxt, char * rStr, int index );
    #+END_SRC

    - newTxt :: arreglo de caracteres de dimension suficiente para contener el
                texto original sobre el que se efectua la busqueda,
                considerando el numero y dimencion de las capturas a
                reemplazar.

    - rStr   :: texto de reemplazo para captura.

    - index  :: indice de captura segun el orden de aparicion dentro de la
                exprecion regular. Pasar un indice incorrecto, coloca una
                copia sin modificacion de la cadena de busqueda sobre el
                arreglo =newLine=.


    en este caso el uso del argumento =index= a diferencia de la
    funcion =getCatch= no se refiere a una "captura" en especifico,
    es decir no importa la cantidad de ocaciones que se ha capturado
    una exprecion, el indice indica la *posicion* dentro de la
    exprecion es decir:

    #+BEGIN_EXAMPLE
      <   <   >  | <   <   >   >   >
      = 1 ==========================
          = 2==    = 2 =========
                       = 3 =
      exprecion de agrupacion con captura
    #+END_EXAMPLE

    modifica una o varias capturas como

    #+BEGIN_EXAMPLE
      <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
      = 1 ==================       = 1 ==================      = 1 ==================
          = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
      modificacion en captura uno  "..." dos                   "..." tres
    #+END_EXAMPLE

** Metacaracteres de busqueda

   - \\ : diagonal
   - \a : "campana"
   - \e : "Esc"
   - \f : salto de página
   - \n : "nueva línea"
   - \r : "retorno de carro"
   - \t : tabulador.
   - \v : tabulador vertical
   - \x : exadecimal  8 bits 00-ff
   - \u : exadecimal 16 bits 0000-FFFF


   - NOTA :: los anteriores caracteres estan por defecto incluidos en
             c, no fue necesario implementarlos.


   - \\d : dígito del 0 al 9.
   - \\D : cualquier carácter que no sea un dígito del 0 al 9.
   - \\w : cualquier carácter alfanumérico.
   - \\W : cualquier carácter no alfanumérico.
   - \\s : espacio en blanco.
   - \\S : cualquier carácter que no sea un espacio en blanco.
   - \\& : caracter no ascii (apartir de 0x80, multibyte o no).


   - NOTA :: los anteriores (y siguietes) caracteres requieren doble
             '\\' para escapar '\'


   - \\| : barra vertical
   - \\^ : acento circunflejo
   - \\$ : signo dolar
   - \\! : negacion
   - \\( : parentesis izquierdo
   - \\) : parentesis derecho
   - \\< : mayor que
   - \\> : menor que
   - \\[ : corchete izquierdo
   - \\] : corchete derecho
   - \\. : punto
   - \\? : interrogacion
   - \\+ : mas
   - \\- : menos
   - \\* : asterisco
   - \\{ : llave izquierda
   - \\} : llave derecha
   - \\# : modificador


   - NOTA :: los anteriores caracteres insertan un caracter con
             significado especial para su busqueda dentro de la
             cadena, incluir el caracter tal cual (sin doble escape
             '\\') en cualquier lugar es erroneo por ejemplo:

             #+BEGIN_EXAMPLE
               "(agrupacion[erronea)"
             #+END_EXAMPLE

             en lugar de

             #+BEGIN_EXAMPLE
               "(agrupacion\\[correcta)"
             #+END_EXAMPLE

             puede generar un error durante el analisis de la cadena
             de busqueda y provocar un ciclo infinito y/o otros
             sucesos apocalipticos.

** ejemplos de uso interesantes

   El fichero =test.c= contiene una amplia variedad de pruebas que son utiles
   como ejemplos de uso, entre estos se encuentran los siguentes:

   #+BEGIN_SRC c
     regexp3( "Raptor Test", "#^$<((C|R)ap C|C|R)(a+p{1}tor)\\s?((\\Se)(st))>" );
   #+END_SRC

   Busqueda y captura de las posibles cadenas:

   - "Cap Captor Test"
   - "Rap Captor Test"
   - "Captor Test"
   - "Raptor Test"
   - "Cap CaaptorTest"
   - "Rap CaaptorTest"
   - ...


   #+BEGIN_SRC c
     regexp3( "<< abcde : fghi jklm :: nrstu vwxyz", "#^\\s*<[\\<^_\\>]{2}>\\s+<#!( (\\<:|::|:\\>|\\>:\\<) )+> <\\<:|::|:\\>|\\>:\\<> <.*>" );
   #+END_SRC

   1. Cadena que inicia con cero o mas espacios
   2. Captura dos caracteres de la agrupacion =[\\<^_\\>]=
   3. Debe contuniuar uno a mas espacios en blanco
   4. Captura caracteres mientras no coincida con el patron =(
      (\\<:|::|:\\>|\\>:\\<) )= (espacio segudo por "<:", "::", ":>",
      ">:<", segido por espacio)
   5. La cadena se detuvo en el patron anterior, capturalo
   6. Y para finalizar captura el resto de la cadena


   el resultado serian cuatro capturas (| para resaltar margenes de captura)

   #+BEGIN_EXAMPLE
     |<<|
     |abcde : fghi jklm|
     |::|
     |nrstu vwxy|
   #+END_EXAMPLE

   #+BEGIN_SRC c
     regexp3( "1999-12-05", "<(\\d){2,4}(\\-|/)(\\d)*(\\W{1})(\\d+)>" );
   #+END_SRC

   captura algo parecido a una fecha (cifras y separadores) separado
   por '-' o '/' y un caracter no alfanumerico

   #+BEGIN_SRC c
      regexp3( "<a href=\"https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular\">", "(https?://)<[^\"]*>" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "contacto (nasciiboy@gmail.com) $$", "<\\w+@\\w+\\.\\w+>" );
   #+END_SRC

   capturar algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?<\\d{4}>\\D?" );
   #+END_SRC

   capturar cifras de cuatro digitos.

* Hacking

  Cual es el algoritmo para resolver una exprecion regular?

  1. Dividir la expresion en sus rutas principales.

     Las rutas se marcan mediante el signo '|' que indica multiples
     opciones a seguir.

     #+BEGIN_EXAMPLE
       ruta uno | ruta dos | ruta n
     #+END_EXAMPLE

     La posicion de cada expresion es indicativa del orden en que debe
     resolverse. Una ruta principal se encuentra en el nivel de
     anidamiento *cero* es decir esta fuara de cualquier nivel de
     agrupamiento.

     #+BEGIN_EXAMPLE
       (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       = 0 ================================================
       = 1 ======   = 1 ==========================
                      = 2 ======================
     #+END_EXAMPLE

     un nuevo nivel de anidamiento surge al agrupar una parte de la
     exprecion iniciando con '(' y finalizando con ')'. Cada '('
     aumenta el anidamiento en 1 y cada ')' lo disminulle en 1, si
     encontramas '|' al tener anidamiento 0, hemos encontrado una ruta
     principal.

     la funcion =walker= optiene cada ruta pricipal secuencalmente,
     para ser enviada a =trekking= (senderista) quien debe reducirla a
     expreciones aun mas sencillas.

     #+BEGIN_EXAMPLE
       inicio     # (ruta uno) | ( (ruta dos a | ruta dos b) ) | ruta n

       ## REDUCCION UNO
       ruta uno   # (ruta uno)
       ruta dos   #              ( (ruta dos a | ruta dos b) )
       ruta n     #                                              ruta n

       ## REDUCCION DOS
       ruta uno   #  ruta uno
       ruta dos   #                (ruta dos a | ruta dos b)
       ruta n     #                                              evaluando

       ## REDUCCION TRES
       ruta uno   #  evaluando
       ruta dos a #                 ruta dos a
       ruta dos b #                              ruta dos b
       ruta n     #                                              terminado

       ## REDUCCION TRES
       ruta uno   #  terminado
       ruta dos a #                 evaluando
       ruta dos b #                              evaluando
     #+END_EXAMPLE

  2. Una ruta principal debe descomponerse en senderos o trayectos,
     eliminando niveles de anidamiento y obteniendo nuevas rutas hasta
     dejar cadenas que puedan compararse directamente.

     La funcion =trekking= envia lo que internamente considera una
     ruta a la funcion =tracker=, la cual corta y marca trayectos
     segun el contexto.

     #+BEGIN_EXAMPLE
       trekking 1 # (ruta uno)
       tracker       ruta uno
     #+END_EXAMPLE

     en este punto cada nuevo =track= es evaluado por =isPath()= en
     busca de signos que indiquen la necesidad de seguir reduciendo la
     exprecion en rutas, metacaracteres, clases de caracteres, rangos,
     y repeticiones. De ser esto necesario, el trayecto se enviara a
     =walker= para crear un nuevo ciclo de analisis (he aqui el paso
     recursivo). De lo contrario el =track= es comparable directamente
     y se optiene un resultado que es enviado a =walker= quien
     responde a =regexp3=.

  3. optener el numero de ciclos de repeticion para cada
     ruta/trayecto/expresion

     una vez que =tracker= a reducido una ruta a trayecto, envia dicho
     trayecto a =setLoops= quien dependiento lo que encuentre a
     continuacion establece el numero de repeticiones en las variables
     =LoopRange(Min|Max)= (miembros de la estructura =Path=).

     #+BEGIN_EXAMPLE
       trekking  a-z    texto     (ruta uno)  *c       ?[abc]{2,3}
       tracker   a-z    | texto   | ruta uno  | c      | abc
       tipo      RANGEAB| SIMPLE  | GROUP     | SIMPLE | BRACKET
       continua  t      | (       | *         | ?      | {
       setLoops  1-1    | 1-1     | 0-INF     | 0-1    | 2-3
       continua  t      | (       | c         | [      | '\0'
     #+END_EXAMPLE

     si la exprecion siguiente es siginificativa =setLoops= corta y
     establece una nueva posicion al fin de dicha exprecion.


  El siguiente diagrama ofrece una vision aproximada del
  funcionamiento del programa.

  file:regexp3.jpg

** Macros

   #+BEGIN_SRC c
     #define TRUE                  1
     #define FALSE                 0
     #define CATCHS               24
     #define INF               65536

     #define MOD_ALPHA             1
     #define MOD_OMEGA             2
     #define MOD_LONLEY            4
     #define MOD_NEGATION          8
   #+END_SRC

   =INF= establece el numero maximo de ciclos de repeticion para cada
   =track=.

   =CATCHS= establece la cantidad de capturas maximas detro de cada
   busqueda.

   las siguentes cuatro constantes representan modificadores de segmentos de
   la expresion regular, se utiliza la constante en conjunto con una mascara
   de bits AND, por ello el valor debe representar una potencia de dos

   los primeros tres modificadores solo actuan sobre la expresion de forma
   global, es decir deben colocarse al inicio de la expresion. colocarlos en
   otra seccion de la expresion no tiene ningun efecto

   =MOD_ALPHA= (al inicio de linea)

   =MOD_OMEGA= (al final de linea)

   =MOD_LONLEY= (deteren a la primer coincidencia)

   =MOD_NEGATION= (mientras no coincida con ...)

** Estructuras y enumeraciones

   #+BEGIN_SRC c
     struct TEXT {
       char *ptr;
       int   pos;
       int   len;
     };
   #+END_SRC

   =ptr= apunta al inicio de la cadena sobre la que se efectua la
   busqueda, =pos= marca la posicion actual sobre la que se encuentra
   la busqueda y =len= contiene la longitud de la cadena.

   #+BEGIN_SRC c
     enum TYPE { SIMPLE, PATH, HOOK, GROUP, BRACKET, RANGEAB, META, POINT, UTF8 };

     struct RE {
       char          *ptr;
       int            len;
       enum     TYPE  type;
       unsigned char  mods;
       unsigned int   loopsMin, loopsMax;
     };
   #+END_SRC

   =RE= contiene la exprecion regular, deacuerdo a cada funcion puede ser
   llamada =regx=, =path=, o =track= para indicar si se trata de la ruta
   principal, o una seccion de esta.

   =ptr= y =len= indican el inicio y longitud de la exprecion.

   =mods= son modificadores del comportamiento de la exprecion

   =type= indica el tipo.

   - =PATH= ruta principal.
   - =GROUP= agrupacion.
   - =HOOK= agrupacion y captura.
   - =SIMPLE= texto simple directamente comparable.
   - =BRACKET= clase de caracteres
   - =RANGEAB= rango de caracteres.
   - =META= metacaracter.
   - =POINT= punto.
   - =UTF8= caracter multibyte con codificacion UTF8


   =loopsMin= y =loopsMax= almacenan el rango de repeticiones,
   normalmente =1= y =1= respectivamente.

   #+BEGIN_SRC c
     struct CATch {
       char *ptr[CATCHS];
       int   len[CATCHS];
       int   id [CATCHS];
       int   idx;
       int   index;
     } Catch;
   #+END_SRC

   =Catch= almacena un arreglo de apuntadores (=ptr=) al inicio de
   cada captura y su longitud =len=. =index= indica el numero total de
   capturas.

   =id= identifica el orden de aparicion dentro de la exprecion
   regular, =idx= es una variable auxiliar para obtener el
   identificador.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y
  acorde a ello se utiliza la licencia GNU GPL Version 3. Cualquier
  obra que incluya o derive codigo de esta libreria, debera cumplir
  con los terminos de esta licencia.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
