#+TITLE: Recursive Regexp Raptor (regexp3)
#+AUTHOR: nasciiboy
#+LANGUAGE: es
#+STARTUP: showall


* Caracteristicas

  - Manejo sencillo,

  - Sin verificacion de errores en la exprecion resivida. C no es asi.

  - Numero de rutas y agrupamientos limitado solo por la capacidad del
    sistema/hardware

  - El codigo mas compacto y claro que alla precenciado nunca antes
    alguna libreria regexp humana.

  - Cero dependencias, C puro.

  - Soporte UTF8 (2-6 bytes) (experimental)

  - Manejo no explicito de memoria dinamica. No encontrara ningun
    =malloc=, =calloc=, =free=, ...

  - Recuperacion de capturas de forma individual

  - Reemplazo de capturas

  - Creacion de una nueva linea agregando capturas

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y
  reemplazo de expresiones regulares escrita en lenguaje C, buscando
  lo siguiente:

  - Cumplir con la mayoria de funciones esperadas por una libreria de
    este tipo.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar peticion explicita de memoria dinamica.

  - Ser util como material de aprendizaje.

** Motivacion

   Partiendo de que C no dispone de una libreria estandar de
   expresiones regulares, se planteo la busqueda de una alternativa
   funcional de la cual aprender un poco, GNU tiene tanto gawk como la
   libreria regexp, sin embargo el autor de este trabajo (que igual y
   es un poco retard) encontro en ambas codigo rebuscado y mistico
   repartido en varios ficheros, llenos de macros y variables
   cripticas.

   La siguiente opcion fue [[https://github.com/cesanta/slre][slre]] cuya principal cararacteristica
   promocional es tener codigo compacto, aunque no mas claro, que
   ademas fallaba si existia un nivel de anidamiento siguiente al
   previo es decir:

   #+BEGIN_EXAMPLE
     (((a|b)))((x|b))
     = 1 =====        OK
              = 2 === ERROR
   #+END_EXAMPLE

   desepcionado y tras un retiro a la isla de la meditacion onanista
   el autor se propuso hacer su propia libreria con casinos y
   colegialas japonesas.

** Desarrollo y pruebas

   Se ha echo uso del "editor" GNU Emacs y el compilador gcc version
   5.3.1, corriendo en fedora 23.

   para compilar solo hace falta

   #+BEGIN_SRC sh
     gcc test.c regexp3.c
   #+END_SRC

   para la ejecucion basta un confiable

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  Para incluir Recursive Regexp Raptor en su codigo necesita colocar
  los ficheros =regexp3.c=, =regexp3.h= y =charUtils.h= dentro de la
  carpeta de su proyecto. Debe incluir el encabezado

  #+BEGIN_SRC c
    #include "regexp3.h"
  #+END_SRC

  donde desee utilizar la libreria, y finalmente agregar =regexp3.c=
  al comando de compilacion

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3.c
  #+END_SRC

  La unica funcion de busqueda es =regexp3= aqui su prototipo:

  #+BEGIN_SRC c
    int regexp3( char *line, char *exp );
  #+END_SRC

  - line :: apuntador a cadena sobre la que efectuar la busqueda, debe
            finalizar con el signo de terminacion '\0'.

  - exp  :: apuntador a cadena que contiene la expresion regular de
            busqueda, debe finalizar con el signo de terminacion '\0'.


  La funcion regresa el numero de coincidencias localizadas dentro del
  argumento =line= es decir de =0= (ninguna) a =n= coincidencias.

  La sintaxis de la exprecion regular puede contener:

  - busqueda de texto /simple/ en cualquier lugar de una linea:

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Raptor" );
    #+END_SRC

  - busqueda posicional al inicio '^exp'

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "^Raptor" );
    #+END_SRC

  - busqueda posicional al final 'exp$'

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Test$" );
    #+END_SRC

  - busqueda posicional al inicio y final "^exp$"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "^Raptor Test$" );
    #+END_SRC

    - NOTA :: Los caracteres de busqueda posicional solo tienen efecto
              al colocarse al incio o final del patron de busqueda,
              colocar estos caracteres en cualquier otra posicion,
              agrega dicho caracter *tal cual* detro del patron de
              busqueda, es decir no tiene ningun siginificado
              especial.


  - detener con la primer coincidencia "?exp"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "?Raptor Test" );
    #+END_SRC

    - NOTA :: el caracter '?' se utiliza para establecer si una
              exprecion puede o no estar presente en la busqueda. Solo
              al colocarse al inicio de la exprecion indica "Detener
              la busqueda con la primer coincidencia"


  - opciones de busqueda multiples "exp1|exp2"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Dinosaur|T Rex|Raptor|Triceratops" );
    #+END_SRC

  - Rango de caracteres "x-n"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Ra-zptor" );
    #+END_SRC

    - NOTA :: Los rangos de caracteres pueden colocarse dentro de una
              agrupacion, conjunto de caracteres y texto simple.

    - NOTA :: Solo estan soportados rangos de caracteres ASCII


  - Conjunto de caracteres "[abc]"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R[uoiea]ptor" );
    #+END_SRC

    - NOTA :: Dentro de un conjunto de caracteres los siguientes
              caracteres carecen de significado especial =[|)}= y
              pueden incluire tal cual si necesidad de escapar el
              caracter.

      #+BEGIN_SRC c
        regexp3( "$|)}^", "([$|)}^])+" );
      #+END_SRC


  - Rango(s) dentro de conjunto de caracteres "[x-n]"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R[a-z]ptor" );
    #+END_SRC

  - inversion de conjunto de caracteres  "[^abc]"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R[^uoie]ptor" );
    #+END_SRC

  - coincidencia con cualquier caracter '.'

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R.ptor" );
    #+END_SRC

  - coincidencia cero o una ves '?'

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Ra?ptor" );
    #+END_SRC

  - coincidencia una o mas veces '+'

    #+BEGIN_SRC c
      regexp3( "Raaaptor Test", "Ra+ptor" );
    #+END_SRC

  - coincidencia cero o mas veces '*'

    #+BEGIN_SRC c
      regexp3( "Raaaptor Test", "Ra*ptor" );
    #+END_SRC

  - rango de coincidencias "{n1,n2}"

    #+BEGIN_SRC c
      regexp3( "Raaaptor Test", "Ra{0,100}ptor" );
    #+END_SRC

  - numero de coincidencia especifico '{n1}'

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "Ra{1}ptor" );
    #+END_SRC

  - caracter ascii en notacion octal "\ooo"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R\141ptor" );
    #+END_SRC

  - caracter ascii en notacion hexadecimal "\xhh"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "R\x61ptor" );
    #+END_SRC

  - caracter unicode "\uhhhh"

    #+BEGIN_SRC c
      regexp3( "R△ptor Test", "R\u25B3ptor" );
    #+END_SRC

    o

    #+BEGIN_SRC c
      regexp3( "R△ptor Test", "R△ptor" );
    #+END_SRC

    tambien

    #+BEGIN_SRC c
      regexp3( "R△ptor Test", "R[△]ptor" );
    #+END_SRC

  - escape de caracter con significado especial "\\c"

    los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*',
    '{', '}', '-' y '\' indican como debe procesarse la exprecion regular,
    colocar alguno de estos caracteres tal cual, sin tener en cuenta
    una correcta sintaxis dentro de la exprecion, puede generar bucles
    infinitos al igual que errores por violacion de segmento.

    anteceder cualquier caracter (excluyendo cadenas de escape propias
    de C) con doble diagonal =\=, elimina (de tener) el significado
    especial y permite buscar tal cual el caracter.

    #+BEGIN_SRC c
      regexp3( "|()<>[]?+*{}-\\", "<\\|\\(\\)\\<\\>\\[\\]\\?\\+\\*\\{\\}\\-\\\\>" );
    #+END_SRC

    o

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "\\R\\a\\p\\t\\o\\r\\ \\T\\es\\t" );
    #+END_SRC

  - agrupacion "(exp)"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "(Raptor)" );
    #+END_SRC

  - agrupacion con captura "<exp>"

    #+BEGIN_SRC c
      regexp3( "Raptor Test", "<Raptor>" );
    #+END_SRC

** Comportamiento al recorrer el texto de busqueda

   Al localizar una coincidencia, la nueva busqueda inicia a partir
   del final de dicha coincidencia en lugar del caracter siguiente al
   inicio de la coincidencia. Si desea realizar una busqueda caracter
   a caracter (incluyendo caracteres UTF-8 de longitud variable)
   elimine el fragmento de codigo

   #+BEGIN_SRC c
     match && pathLine.pos ? pathLine.pos :
   #+END_SRC

   dentro de la funcion =regexp3= en el fichero =regexp3.c=.

   Adicionalmente podria no estar interesado en utilizar la libreria
   con caracteres no ASCII, para obtener una considerable mejora de
   rendimiento serian necesarias algunas modificaciones menores como
   eliminar todo el codigo referente a =UTF=, la funcion =utf8meter=,
   y la constante =xooooooo=, asi como substituir la aparicion de
   =utf8meter= por =1=, =++= o alguna expresion equivalente, donde sea
   necesario.

** Recuperacion de captura

   Cualquier agrupacion "<exp>" exitosa, genera una captura del texto
   localizado, dichas capturas se almacenan segun el orden de
   aparicion y posicion dentro de la agrupacion por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion dentro de la agrupacion es capturada mas de una vez
   dentro de la linea de busqueda el indice, se incrementa segun su
   aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     primer captura               segunda captura      tercer captura
   #+END_EXAMPLE

   la funcion =cpytCatch= copia la captura dentro de un arreglo de
   caracteres, aqui su prototipo:

   #+BEGIN_SRC c
     char * cpyCatch( char * lineCatch, int index )
   #+END_SRC

   - lineCatch :: puntero lo suficientemete grande para contener la
                  captura.

   - index     :: indice de agrupacion a recuperar de =1= a =n=.



   la funcion regeresa un apuntador a la captura terminada en '\0'. Un
   indice incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero de agrupaciones capturadas utlice
   =totCatch=:

   #+BEGIN_SRC c
     int totCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=. Podria utilzar esta y la
   anterior funcion para imprimir las agrupaciones capturadas con una
   funcion como:

   #+BEGIN_SRC c
     void printCatch(){
       char lineCatch[128];
       int i = 0, max = totCatch();

       while( ++i <= max )
         printf( "#%d# >%s<\n", i, cpyCatch( lineCatch, i ) );
     }
   #+END_SRC

*** =gpsCatch()= y =lenCatch()=

    una alternativa a =cpyCatch()=, son las funciones =gpsCatch()= y
    =lenCatch()=. La primera regresa un puntero a la posicion donde
    fue encontrada la captura, la segunda regresa la longitud de la
    captura.

    #+BEGIN_SRC c
      char * gpsCatch( int index );
      int lenCatch   ( int index );
    #+END_SRC

    un ejemplo de uso seria:

    #+BEGIN_SRC c
      void printCatch(){
        int i = 0, max = totCatch();

        while( ++i <= max )
          printf( "#%d# >%.*s<\n", i, lenCatch( i ), gpsCatch( i ) );
      }
    #+END_SRC

*** Colocar capturas dentro de una linea

    #+BEGIN_SRC c
      char * newLineCatch( char * newLine, char * str );
    #+END_SRC

    el argumento =str= contiene el texto con el cual formar la nueva
    cadena asi como indicadores de cuales capturas colocar. Colocar
    texto no requiere ningun eschizo mistico, texto tal cual, por otro
    lado indicar la captura requiere cocar el signo '\' seguido del
    numero de captura:

    #+BEGIN_SRC c
      str = "captura 1 >>\\1<< captura 2 >>\\2<< captura 747 >>\\747<<";
    #+END_SRC

    para escapar el caracter '\' dentro de la nueva cadena
    "\\". Dentro de la cadena del programa tendra que colocar los
    respectivos escapes del escape es decir:

    #+BEGIN_CENTER
      cadena = "\\\\Escape\\\\"
    #+END_CENTER

    =newLine= es la direccion de un arrglo de caracteres del tamaño
    necesario para almacenar la linea resultante.

** Reemplazo de captura

   El reemplazo opera sobre un arreglo de caracteres en el cual se
   coloca la linea de busqueda con las capturas reemplazadas, la
   funcion encargada de esta labor es =replaceCatch=, su prototipo es:

   #+BEGIN_SRC c
     char * replaceCatch( char * newLine, char * str, int index );
   #+END_SRC

   - newLine :: arreglo de caracteres lo suficientemente grande para
                contener la linea sobre la que se efectua la busqueda,
                tomando en cuenta el numero y dimencion de capturas a
                reemplazar.

   - str     :: cadena de caracteres con la cual reemplazar la
                captura.

   - index   :: indice de captura segun el orden de aparicion dentro
                de la exprecion regular. Pasar un indice incorrecto,
                coloca una copia sin modificacion de la cadena de
                busqueda sobre el arreglo =newLine=.


   en este caso el uso del argumento =index= a diferencia de la
   funcion =getCatch= no se refiere a una "captura" en especifico,
   es decir no importa la cantidad de ocaciones que se ha capturado
   una exprecion, el indice indica la *posicion* dentro de la
   exprecion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
     exprecion de agrupacion con captura
   #+END_EXAMPLE

   modifica una o varias capturas como

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
     = 1 ==================       = 1 ==================      = 1 ==================
         = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
     modificacion en captura uno  "..." dos                   "..." tres
   #+END_EXAMPLE

** Metacaracteres de busqueda

   - \\ : diagonal
   - \a : "campana"
   - \e : "Esc"
   - \f : salto de página
   - \n : "nueva línea"
   - \r : "retorno de carro"
   - \t : tabulador.
   - \v : tabulador vertical
   - \x : exadecimal  8 bits 00-ff
   - \u : exadecimal 16 bits 0000-FFFF


   - NOTA :: los anteriores caracteres estan por defecto incluidos en
             c, no fue necesario implementarlos.


   - \\d : dígito del 0 al 9.
   - \\D : cualquier carácter que no sea un dígito del 0 al 9.
   - \\w : cualquier carácter alfanumérico.
   - \\W : cualquier carácter no alfanumérico.
   - \\s : espacio en blanco.
   - \\S : cualquier carácter que no sea un espacio en blanco.
   - \\& : caracter no ascii (apartir de 0x80, multibyte o no).


   - NOTA :: los anteriores (y siguietes) caracteres requieren doble
             '\\' para escapar '\'


   - \\| : barra vertical
   - \\^ : acento circunflejo
   - \\$ : signo dolar
   - \\( : parentesis izquierdo
   - \\) : parentesis derecho
   - \\< : mayor que
   - \\> : menor que
   - \\[ : corchete izquierdo
   - \\] : corchete derecho
   - \\. : punto
   - \\? : interrogacion
   - \\+ : mas
   - \\- : menos
   - \\* : asterisco
   - \\{ : llave izquierda
   - \\} : llave derecha


   - NOTA :: los anteriores caracteres insertan un caracter con
             significado especial para su busqueda dentro de la
             cadena, incluir el caracter tal cual (sin doble escape
             '\\') en cualquier lugar es erroneo por ejemplo:

             #+BEGIN_EXAMPLE
               "(agrupacion[erronea)"
             #+END_EXAMPLE

             en lugar de

             #+BEGIN_EXAMPLE
               "(agrupacion\\[correcta)"
             #+END_EXAMPLE

             puede generar un error durante el analisis de la cadena
             de busqueda y provocar un ciclo infinito y/o otros
             sucesos apocalipticos.

** ejemplos interesantes de busqueda

   #+BEGIN_SRC c
     regexp3( "Raptor Test", "^<((C|R)ap C|C|R)(a+p{1}tor)\\s?((\\Se)(st))>$" );
   #+END_SRC

   Busqueda y captura de las posibles cadenas:

   - "Cap Captor Test"
   - "Rap Captor Test"
   - "Captor Test"
   - "Raptor Test"
   - "Cap CaaptorTest"
   - "Rap CaaptorTest"
   - ...


   #+BEGIN_SRC c
     regexp3( "1999-12-05", "<(\\d){2,4}(\\-|/)(\\d)*(\\W{1})(\\d+)>" );
   #+END_SRC

   captura algo parecido a una fecha (cifras y separadores) separado
   por '-' o '/' y un caracter no alfanumerico

   #+BEGIN_SRC c
      regexp3( "<a href=\"https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular\">", "(https?://)<[^\"]*>" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "contacto (nasciiboy@gmail.com) $$", "<\\w+@\\w+\\.\\w+>" );
   #+END_SRC

   capturar algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "1. rango entre 1985-2014.", "\\D?<\\d{4}>\\D?" );
   #+END_SRC

   capturar cifras de cuatro digitos.

* Hacking

  Cual es el algoritmo para resolver una exprecion regular?

  1. Dividir la expresion en sus rutas principales.

     Las rutas se marcan mediante el signo '|' que indica multiples
     opciones a seguir.

     #+BEGIN_EXAMPLE
       ruta uno | ruta dos | ruta n
     #+END_EXAMPLE

     La posicion de cada expresion es indicativa del orden en que debe
     resolverse. Una ruta principal se encuentra en el nivel de
     anidamiento *cero* es decir esta fuara de cualquier nivel de
     agrupamiento.

     #+BEGIN_EXAMPLE
       (ruta uno) | ( (ruta dos a | rutad dos b) ) | ruta n
       = 0 ================================================
       = 1 ======   = 1 ==========================
                      = 2 ======================
     #+END_EXAMPLE

     un nuevo nivel de anidamiento surge al agrupar una parte de la
     exprecion iniciando con '(' y finalizando con ')'. Cada '('
     aumenta el anidamiento en 1 y cada ')' lo disminulle en 1, si
     encontramas '|' al tener anidamiento 0, hemos encontrado una ruta
     principal.

     la funcion =walker= optiene cada ruta pricipal secuencalmente,
     para ser enviada a =trekking= (senderista) quien debe reducirla a
     expreciones aun mas sencillas.

     #+BEGIN_EXAMPLE
       inicio     # (ruta uno) | ( (ruta dos a | ruta dos b) ) | ruta n

       ## REDUCCION UNO
       ruta uno   # (ruta uno)
       ruta dos   #              ( (ruta dos a | ruta dos b) )
       ruta n     #                                              ruta n

       ## REDUCCION DOS
       ruta uno   #  ruta uno
       ruta dos   #                (ruta dos a | ruta dos b)
       ruta n     #                                              evaluando

       ## REDUCCION TRES
       ruta uno   #  evaluando
       ruta dos a #                 ruta dos a
       ruta dos b #                              ruta dos b
       ruta n     #                                              terminado

       ## REDUCCION TRES
       ruta uno   #  terminado
       ruta dos a #                 evaluando
       ruta dos b #                              evaluando
     #+END_EXAMPLE

  2. Una ruta principal debe descomponerse en senderos o trayectos,
     eliminando niveles de anidamiento y obteniendo nuevas rutas hasta
     dejar cadenas que puedan compararse directamente.

     La funcion =trekking= envia lo que internamente considera una
     ruta a la funcion =tracker=, la cual corta y marca trayectos
     segun el contexto.

     #+BEGIN_EXAMPLE
       trekking 1 # (ruta uno)
       tracker       ruta uno
     #+END_EXAMPLE

     en este punto cada nuevo =track= es evaluado (=isPath()=) en
     busca de signos que indiquen la necesidad de seguir reduciendo la
     exprecion en rutas, metacaracteres, clases de caracteres, rangos,
     y repeticiones. De ser esto necesario, el trayecto se enviara a
     =walker= para crear un nuevo ciclo de analisis (he aqui el paso
     recursivo). De lo contrario el =track= es comparable directamente
     y se optiene un resultado que es enviado a =walker= quien
     responde a =regexp3=.

  3. optener el numero de ciclos de repeticion para cada
     ruta/trayecto/expresion

     una vez que =tracker= a reducido una ruta a trayecto, envia dicho
     trayecto a =setLoops= quien dependiento lo que encuentre a
     continuacion establece el numero de repeticiones en las variables
     =LoopRange(Min|Max)= (miembros de la estructura =Path=).

     #+BEGIN_EXAMPLE
       trekking  a-z    texto     (ruta uno)  *c       ?[abc]{2,3}
       tracker   a-z    | texto   | ruta uno  | c      | abc
       tipo      RANGEAB| SIMPLE  | GROUP     | SIMPLE | BRACKET
       continua  t      | (       | *         | ?      | {
       setLoops  1-1    | 1-1     | 0-INF     | 0-1    | 2-3
       continua  t      | (       | c         | [      | '\0'
     #+END_EXAMPLE

     si la exprecion siguiente es siginificativa =setLoops= corta y
     establece una nueva posicion al fin de dicha exprecion.


  El siguiente diagrama ofrece una vision aproximada del
  funcionamiento del programa.

  file:regexp3.jpg

** Macros

   #+BEGIN_SRC c
     #define TRUE       1
     #define FALSE      0
     #define INF    65536
     #define CATCHS    24
   #+END_SRC

   =INF= establece el numero maximo de ciclos de repeticion para cada
   =track=.

   =CATCHS= establece la cantidad de capturas maximas detro de cada
   busqueda.

** Estructuras y enumeraciones

   #+BEGIN_SRC c
     struct PathLine {
       char *line;
       int   pos;
       int   len;
     };
   #+END_SRC

   =line= apunta al inicio de la cadena sobre la que se efectua la
   busqueda, =pos= marca la posicion actual sobre la que se encuentra
   la busqueda y =len= contiene la longitud de la cadena.

   #+BEGIN_SRC c
     enum PTYPE { PATH, GROUP, HOOK, SIMPLE, BRACKET, RANGEAB, META, POINT, UTF8 };

     struct Path {
       int   len;
       char *ptr;
       enum   PTYPE type;
       int   loopsMin, loopsMax;
     };
   #+END_SRC

   =Path= contiene la exprecion regular, deacuerdo a cada funcion
   puede ser llamada =path=, =track= o =text= para indicar si se trata
   de la ruta principal, un divicion de esta, o texto para una
   comparacion directa.

   =ptr= y =len= indican el inicio y longitud de la exprecion.

   =type= indica el tipo.

   - =PATH= ruta principal.
   - =GROUP= agrupacion.
   - =HOOK= agrupacion y captura.
   - =SIMPLE= texto simple directamente comparable.
   - =BRACKET= clase de caracteres
   - =RANGEAB= rango de caracteres.
   - =META= metacaracter.
   - =POINT= punto.
   - =UTF8= caracter multibyte con codificacion UTF8


   =loopsMin= y =loopsMax= almacenan el rango de repeticiones,
   normalmente =1= y =1= respectivamente.

   #+BEGIN_SRC c
     struct CATch {
       char *ptr[CATCHS];
       int   len[CATCHS];
       int   id [CATCHS];
       int   idx;
       int   index;
     } Catch;
   #+END_SRC

   =Catch= almacena un arreglo de apuntadores (=ptr=) al inicio de
   cada captura y su longitud =len=. =index= indica el numero total de
   capturas.

   =id= identifica el orden de aparicion dentro de la exprecion
   regular, =idx= es una variable auxiliar para obtener el
   identificador.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y
  acorde a ello se utiliza la licencia GNU GPL Version 3. Cualquier
  obra que incluya o derive codigo de esta libreria, debera cumplir
  con los terminos de esta licencia.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
