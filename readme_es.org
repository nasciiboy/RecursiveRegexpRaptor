#+TITLE:    Recursive Regexp Raptor (regexp3)
#+AUTHOR:   nasciiboy
#+LANGUAGE: es
#+STARTUP:  showall

lang: [[file:readme.org][en]]

regexp4: [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][aqui]]

raptor-book (borrador) : [[https://github.com/nasciiboy/raptor-book/][aqui]]

* Caracteristicas

  - Manejo sencillo,

  - Sin verificacion de errores.

  - Solo expresiones regulares

  - El codigo mas compacto y claro que alla precenciado nunca antes
    alguna libreria regexp humana.

  - Cero dependencias. Ni la libreria estandar de C esta precente *C PURO*.

  - Manejo no explicito de memoria dinamica. Ningun =malloc=, =calloc=, =free=,
    ...

  - Conteo de coincidencias

  - Capturas

  - Reemplazo de capturas

  - Colocacion de capturas especificas dentro de un arreglo

  - Negacion de expreciones (experimental)

  - Referencia dentro de la exprecion a capturas previas

  - Soporte UTF8

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y reemplazo de
  expresiones regulares escrita en lenguaje C desce cero, intentando lograr lo
  siguiente:

  - Contar con la mayoria de caracteristicas presentes en cualquier otra
    libreria regexp.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar la peticion explicita de memoria dinamica.

  - Evitar el uso de ninguna libreria externa, incluida la libreria estandar.

  - Ser util como material de aprendizaje.


  Existen dos desarrollos paralelos de esta libreria el primero (el presente) se
  centra en la simplicidad y el codigo, el segundo aun en fase beta ([[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4]])
  intenta alcanzar la maxima velocidad posible implemetando una "tabla de
  instrucciones". En ambos casos el algoritmo parte de cero, y solo se hace uso
  de C tal cual la primer vercion ocupa un total de *510 lineas de codigo* y la
  segunda *686 lineas*. enjoy!

** Motivacion

   C no dispone de una libreria estandar de expresiones regulares, si bien
   existen varias implementaciones, como pcre, la libreria regexp.h del proyecto
   GNU, regexp del sistema operativo Plan 9, y algunas otras mas, el autor de
   este trabajo (que igual y es un poco retard) encontro en todas codigo
   rebuscado y mistico repartido en varios ficheros, llenos de macros, guiones
   bajos y variables cripticas. Incapas de entender nada y tras un retiro a la
   isla de la meditacion onanista el autor se propuso hacer su propia libreria
   con casinos y colegialas japonesas.

** Desarrollo y pruebas

   Se ha utilizado GNU Emacs (el unico y verdadero sistema operativo), los
   compiladores gcc (6.3.1) y clang (LLVM) 3.8.1, konsole y fish, corriendo en
   Freidora 25.

   existen dos pruebas para la libreria, la primera es una bateria de pruebas
   ascii en el fichero =ascii_test.c=.

   para probar la vercion ascii de la libreria

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_ascii.c
   #+END_SRC

   para la vercion UTF8

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_utf8.c
   #+END_SRC

   la segunda bateria de pruebas es exclusiva de =regexp3_utf8.c=

   #+BEGIN_SRC sh
     gcc utf8_test.c regexp3_utf8.c
   #+END_SRC

   en cualquiera de los casos ejecute con

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  Para incluir Recursive Regexp Raptor en su codigo necesita colocar los
  ficheros =regexp3.h=, =charUtils.h= y de pendiendo del caso de uso
  =regexp3_ascii.c= o =regexp3_utf8.c= dentro de la carpeta de su
  proyecto. Debe incluir el encabezado

  #+BEGIN_SRC c
    #include "regexp3.h"
  #+END_SRC

  y por ultimo compilar bien con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_ascii.c
  #+END_SRC

  o con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_utf8.c
  #+END_SRC

  obviamente, compilar con optimizacion proporciona una disminucion drastica del
  tiempo de ejecucion, intente con =-O3=

** funcion =regexp3()=

   Esta el la unica funcion de busqueda, aqui su prototipo:

   #+BEGIN_SRC c
     int regexp3( const char *txt, const char *re );
   #+END_SRC

   - txt  :: apuntador a cadena sobre la que efectuar la busqueda, debe
             finalizar con el signo de terminacion '\0'.

   - re   :: apuntador a cadena que contiene la expresion regular de busqueda,
             debe finalizar con el signo de terminacion '\0'.


   La funcion regresa el numero de coincidencias =0= (ninguna) o =n=
   coincidencias.

   La sintaxis estandar para expresiones regulares utiliza el caracter '=\=',
   lamentablemente este signo entra en "conflicto" con la sintaxis de C, por
   esto e intentando mantener el codigo lo mas sencillo, se ha optado por una
   sintaxis alterna detallada a continuacion

** Sintaxis

   - busqueda de texto en cualquier ubicacion:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Raptor" );
     #+END_SRC

   - multiples opciones de busqueda "exp1|exp2"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Dinosaur|T Rex|Raptor|Triceratops" );
     #+END_SRC

   - coincidencia con cualquier caracter '.'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R.ptor" );
     #+END_SRC

   - coincidencia cero o una ves '?'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra?ptor" );
     #+END_SRC

   - coincidencia una o mas veces '+'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra+ptor" );
     #+END_SRC

   - coincidencia cero o mas veces '*'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra*ptor" );
     #+END_SRC

   - rango de coincidencias "{n1,n2}"

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{0,100}ptor" );
     #+END_SRC

   - numero de coincidencias especifico '{n1}'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra{1}ptor" );
     #+END_SRC

   - numero minimo de coincidencias '{n1,}'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{1,}ptor" );
     #+END_SRC

   - Rango de caracteres "x-n"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra-zptor" );
     #+END_SRC

     - NOTA :: Los rangos son validos en cualquier seccion de la regexp
               (agrupacion, conjunto de caracteres, capturas, texto simple).

     - NOTA :: Solo estan soportados rangos de caracteres ASCII

   - Conjuntos.

     - advertencia :: Los conjuntos de caracteres interpretan todos las signos
       especiales utilizados por la libreria (agrupacion, conjunto, repeticion,
       modificadores...) escape dichos signos colocando antes el signo ':'

     - Conjunto de caracteres "[abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[uoiea]ptor" );
       #+END_SRC

     - Rango dentro de un conjunto de caracteres "[x-n]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[a-z]ptor" );
       #+END_SRC

     - inversion de conjunto de caracteres  "[^abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[^uoie]ptor" );
       #+END_SRC

   - caracteres con codificacion utf8

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R△ptor" );
     #+END_SRC

     tambien

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R[△]ptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una letra ":a"

     #+BEGIN_SRC c
       regexp3( "RAptor Test", "R:aptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea una letra ":A"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Aptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una numero ":d"

     #+BEGIN_SRC c
       regexp3( "R4ptor Test", "R:dptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un numero ":D"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Dptor" );
     #+END_SRC

   - coincidencia con un caracter alfanumerico ":w"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:wptor" );
     #+END_SRC

   - coincidencia con un caracter no alfanumerico ":W"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Wptor" );
     #+END_SRC

   - coincidencia con un caracter que sea un espacio ":s"

     #+BEGIN_SRC c
       regexp3( "R ptor Test", "R:sptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un espacio ":S"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Sptor" );
     #+END_SRC

   - coincidencia con un caracter utf8 ":&"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:&ptor" );
     #+END_SRC

   - escape de caracteres con significado especial ":caracter"

     los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*', '{', '}',
     '-', '#' y '@' indican como debe procesarse la exprecion regular, colocar
     alguno de estos caracteres tal cual, sin tener en cuenta una correcta
     sintaxis dentro de la exprecion, puede generar bucles infinitos al igual
     que errores por violacion de segmento.

     #+BEGIN_SRC c
       regexp3( ":#()|<>", ":::#:(:):|:<:>" );
     #+END_SRC

   - agrupacion "(exp)"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "(Raptor)" );
     #+END_SRC

   - agrupacion con captura "<exp>"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "<Raptor>" );
     #+END_SRC

   - backreferences "@id"

     las referencias necesitan que previamente se halla capturado una exprecion
     mediante "<exp>", luego se coloca el numero de aparicion de la captura
     precidido por '@'

     #+BEGIN_SRC c
       regexp3( "ae_ea", "<a><e>_@2@1" )
     #+END_SRC

   - *negacion de exprecion* "([^(exp)])" o "<[^(exp)]>"

     esta poco convencional exprecion permite el equivalente en otras librerias
     a expreciones tipo

     #+BEGIN_SRC c
       a.*b
     #+END_SRC

     es decir "una 'a' seguida por cualquier cosa que no sea b, seguida por b".
     En esta sintaxis seria

     #+BEGIN_SRC c
       regexp3( "a123456789b", "a([^(b)])*b" );
     #+END_SRC

     esta sintaxis es provicional y no esta execta de fallos, no la tome
     enserio.

   - modificadores de comportamiento

     Existen dos tipos de modificadores. El primero afecta de forma global el
     comportamiento de la exprecion, el segundo afecta secciones en
     especifico. En ambos caso los la sintaxis es la misma, el signo '#',
     seguido por los modificadores,

     los modificadores de alcance global se coloca al inicio, de toda la
     exprecion y son los siguientes

     - busqueda solo al inicio '#^exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^Raptor" );
       #+END_SRC

     - busqueda solo al final '#$exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#$Test" );
       #+END_SRC

     - busqueda al inicio y final "#^$exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^$Raptor Test" );
       #+END_SRC

     - detener con la primer coincidencia "#?exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#?Raptor Test" );
       #+END_SRC

     - buscar por la cadena caracter a caracter "#~"

       de forma predeterminada cuando una exprecion coincide con una region del
       texto de busqueda, la busqueda prosigue a partir del final de dicha
       coincidencia, para ignorar este comportamiento, haciendo que la busqueda
       siempre sea caracter a caracter se utiliza este modificador

       #+BEGIN_SRC c
         regexp3( "aaaaa", "#~a*" );
       #+END_SRC

       en este ejemplo, sin el modificador el resultado seria una coincidencia,
       sin embargo con este modificador la busqueda continua inmediatamente
       despues del siguente caracter regresando cinco coincidencias.

     - ignorar entre minusculas y mayusculas "#*exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#*RaPtOr TeSt" );
       #+END_SRC


     todos los modificadores anteriores son compatibles entre si es decir podria
     buscar

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#^$*?~RaPtOr TeSt" );
     #+END_SRC

     sin embargo los  modificadores  '~' y '?' pierden sentido debido a la
     presencia de '^' y/o '$'.

     una exprecion del tipo:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#$RaPtOr|#$TeSt" );
     #+END_SRC

     es erronea, el modificador despues del '|' se aplicaria la seccion entre
     '|' y '#', es decir cero, con un retorno de erroneo

     los modificadores locales se colocan despues del indicador de repeticion
     (de existir) y afectan la misma region que afectan los indicadores de
     repeticion, es decir caracteres, conjuntos o agrupaciones.

     - ignorar entre minusculas y mayusculas "exp#*"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "(RaPtOr)#* TeS#*t" );
       #+END_SRC

     - no ignorar entre minusculas y mayusculas "exp#/"

       #+BEGIN_SRC c
         regexp3( "RaPtOr TeSt", "#*(RaPtOr)#/ TES#/T" );
       #+END_SRC

** Capturas

   Las capturas se indexan segun el orden de aparicion dentro de la expresion
   por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion coincide mas de una ocacion dentro del texto de busqueda el
   indice, se incrementa segun su aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     coincidencia uno         coincidencia dos         coincidencia tres
   #+END_EXAMPLE

   la funcion =cpytCatch= hace una copia de una la captura dentro de un arreglo
   de caracteres, aqui su prototipo:

   #+BEGIN_SRC c
     char * cpyCatch( char * str, const int index )
   #+END_SRC

   - str   :: puntero lo suficientemete grande para contener la captura.

   - index :: indice de la agrupacion (de =1= a =n=).


   la funcion regeresa un apuntador a la captura terminada en '\0'. Un indice
   incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero capturadas dentro de una busqueda, utlice
   =totCatch=:

   #+BEGIN_SRC c
     int totCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=.

   Podria utilzar esta y la anterior funcion para imprimir las capturadas con
   una funcion como esta:

   #+BEGIN_SRC c
     void printCatch(){
       char str[128];
       int i = 0, max = totCatch();

       while( ++i <= max )
         printf( "[%d] >%s<\n", i, cpyCatch( str, i ) );
     }
   #+END_SRC

*** =gpsCatch()= y =lenCatch()=

    las funciones =gpsCatch()= y =lenCatch()= realizan la misma labor que
    =cpyCatch= con la variante de no utilizar un arreglo, en su lugar la primera
    regresa un puntero a la posicion inicial de la captura dentro del texto de
    busqueda y la segunda regresa la longitud de dicha captura.

    #+BEGIN_SRC c
      int          lenCatch( const int index );
      const char * gpsCatch( const int index );
    #+END_SRC

    el ejemplo anterior con estas fuciones, seria:

    #+BEGIN_SRC c
      void printCatch(){
        int i = 0, max = totCatch();

        while( ++i <= max )
          printf( "[%d] >%.*s<\n", i, lenCatch( i ), gpsCatch( i ) );
      }
    #+END_SRC

*** Colocar capturas dentro de una cadena

    #+BEGIN_SRC c
      char * putCatch( char * newStr, const char * putStr );
    #+END_SRC

    el argumento =putStr= contiene el texto con el cual formar la nueva cadena
    asi como indicadores de cuales capturas colocar. Para indicar la insercion
    de una captura coque el signo '#' seguido del indice de captura. por ejemplo
    el argumento =putStr= podria ser

    #+BEGIN_SRC c
      char *putStr = "captura 1 >>#1<< captura 2 >>#2<< captura 747 >>#747<<";
    #+END_SRC

    =newStr= es un arreglo de caracteres lo suficientemente grande como para
    contener la cadena + las capturas. la funcion regresa un apuntador a la
    posicion inicial de este arreglo, que finaliza con el signo de terminacion
    '\0'.

    para colocar el caracter '#' dentro de la cadena escape '#' con un '#'
    adicional, es decir:

    #+BEGIN_EXAMPLE
      "## comentario"  -> "# comentario"
    #+END_EXAMPLE

*** Reemplazar una captura

    El reemplazo opera sobre un arreglo de caracteres en el cual se coloca el
    texto de busqueda modificando una captura especifica por una cadena de
    texto, la funcion encargada de esta labor es =rplCatch=, su prototipo es:

    #+BEGIN_SRC c
      char * rplCatch( char * newStr, const char * rplStr, const int id );
    #+END_SRC

    - newStr :: arreglo de caracteres de dimension dende se colocara el texto
                original sobre el que se efectua y el texto de reemplazo de las
                capturas.

    - rplStr :: texto de reemplazo para captura.

    - id     :: *identificador* de captura segun el orden de aparicion dentro de
                la exprecion regular. Pasar un indice incorrecto, coloca una
                copia sin modificacion de la cadena de busqueda sobre el arreglo
                =newStr=.


    en este caso el uso del argumento =id= a diferencia de la funcion =getCatch=
    no se refiere a una "captura" en especifico, es decir no importa la cantidad
    de ocaciones que se ha capturado una exprecion, el identificador indica la
    *posicion* dentro de la exprecion en si, es decir:

    #+BEGIN_EXAMPLE
         <   <   >  | <   <   >   >   >
      id = 1 ==========================
      id     = 2==    = 2 =========
      id                  = 3 =
      posicion de la captura dentro de la exprecion
    #+END_EXAMPLE

    la modificacion afecta de este modo

    #+BEGIN_EXAMPLE
      <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
      = 1 ==================       = 1 ==================      = 1 ==================
          = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
      captura uno                  "..." dos                   "..." tres
    #+END_EXAMPLE

** Metacaracteres de busqueda

   - =:d= :: dígito del 0 al 9.
   - =:D= :: cualquier carácter que no sea un dígito del 0 al 9.
   - =:a= :: cualquier caracter que sea una letra (a-z,A-Z)
   - =:A= :: cualquier caracter que no sea una letra
   - =:w= :: cualquier carácter alfanumérico.
   - =:W= :: cualquier carácter no alfanumérico.
   - =:s= :: cualquier caracter de espacio en blanco.
   - =:S= :: cualquier carácter que no sea un espacio en blanco.
   - =:&= :: caracter no ascii (solo en version UTF8).

   - =:|= :: barra vertical
   - =:^= :: acento circunflejo
   - =:$= :: signo dolar
   - =:(= :: parentesis izquierdo
   - =:)= :: parentesis derecho
   - =:<= :: mayor que
   - =:>= :: menor que
   - =:[= :: corchete izquierdo
   - =:]= :: corchete derecho
   - =:.= :: punto
   - =:?= :: interrogacion
   - =:+= :: mas
   - =:-= :: menos
   - =:*= :: asterisco
   - =:{= :: llave izquierda
   - =:}= :: llave derecha
   - =:#= :: modificador
   - =::= :: dos puntos


   adicionalmente utilice la sintaxis propia de c para colocar caracteres como
   nueva linea, tabulador, campana,..., etc. De igual forma puede utilizar la
   sintaxis c para "colocar" caracteres en notacion octal, hexadecimal o
   unicode.

** algunos ejemplos de uso

   El fichero =ascii_test.c= contiene una amplia variedad de pruebas que son
   utiles como ejemplos de uso, entre estos se encuentran los siguentes:

   #+BEGIN_SRC c
     regexp3( "07-07-1777", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>" );
   #+END_SRC

   captura una cadena con formato de fecha, de forma separada dia, separador,
   mes y año. El separador tiene que coincider las dos ocaciones que aparece

   #+BEGIN_SRC c
      regexp3( "https://en.wikipedia.org/wiki/Regular_expression", "(https?|ftp):://<[^:s/:<:>]+></[^:s:.:<:>,/]+>*<.>*" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "<mail>nasciiboy@gmail.com</mail>", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><:.[A-Za-z0-9]{2}>*" );
   #+END_SRC

   capturar por secciones (usuario,sitio,dominio) algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "aa0123aa", "<aa><[^(aa)]>*<aa>" );
   #+END_SRC

   capturar una cadena que contenga "aa", luego captura cualquier cosa que no
   sea "aa" y finalmente captura nuevamente "aa"

* Hacking
** algoritmo
*** Diagrama de flujo

    Esta diagrama es una aproximacion del funcionimento del motor, los nombres no
    se corresponden con los nombres del codigo, para una explicacion completa
    revisar el [[https://github.com/nasciiboy/raptor-book/][libro]]

    #+BEGIN_EXAMPLE
          ┌──────┐
          │inicio│
          └──────┘
              │◀───────────────────────────────────┐
              ▼                                    │
      ┌────────────────┐                           │
      │bucle por cadena│                           │
      └────────────────┘                           │
              │                                    │
              ▼                                    │
       ┌─────────────┐  no   ┌─────────────┐       │
      <│fin de cadena│>────▶<│buscar regexp│>──────┘
       └─────────────┘       └─────────────┘  no coincide
              │ si                  │ coincide
              ▼                     ▼
      ┌────────────────┐    ┌────────────────┐
      │informar: no    │    │informar:       │
      │hay coincidencia│    │hay coincidencia│
      └────────────────┘    └────────────────┘
              │                     │
              │◀────────────────────┘
              ▼
            ┌───┐
            │fin│
            └───┘
    #+END_EXAMPLE

    En esta version de @c(buscar regexp) todos los constructores se optienen por
    una sola funcion:

    #+BEGIN_EXAMPLE
                                                                  ┌───────────────────────────────┐
      ┏━━━━━━━━━━━━━┓                                             ▼                               │
      ┃buscar regexp┃                                   ┌───────────────────┐                     │
      ┗━━━━━━━━━━━━━┛                                   │Optener constructor│                     │
                                                        └───────────────────┘                     │
                                                                  │                               │
                                                                  ▼                               │
                                                          ┌───────────────┐  no  ┌─────────────┐  │
                                                         <│hay constructor│>────▶│terminar: la │  │
                                                          └───────────────┘      │ruta coincide│  │
                                                                  │ si           └─────────────┘  │
                                    ┌──────────┬────────┬─────────┼───────────┬──────────┐        │
                                    ▼          ▼        ▼         ▼           ▼          ▼        │
                              ┌───────────┐┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐  │
                              │alternacion││conjunto││punto││metacaracter││caracter││agrupacion│  │
                              └───────────┘└────────┘└─────┘└────────────┘└────────┘└──────────┘  │
                                    │          │        │         │           │          │        │
                                    ▼          └────────┴─────────┼───────────┘          └────────┤
                             ┌──────────────────┐                 │                               │
                  ┌──────────│ guardar posicion │                 ▼               no              │
                  │          └──────────────────┘       ┌──────────────────┐   coincide           │
                  │          ┌──────────────────┐      <│buscar constructor│>─────────┐           │
                  ▼◀─────────│restaurar posicion│◀──┐   └──────────────────┘          │           │
           ┌───────────────┐ └──────────────────┘   │             │ coincide          │           │
           │recorrer rutas │                        │             ▼                   ▼           │
           └───────────────┘                        │    ┌──────────────────┐ ┌────────────────┐  │
                  │                                 │    │avanzar por cadena│ │terminar, ruta  │  │
                  ▼                                 │    └──────────────────┘ │sin coincidencia│  │
              ┌────────┐   si     ┌─────────────┐   │             │           └────────────────┘  │
             <│hay ruta│>───────▶<│buscar regexp│>──┘             └───────────────────────────────┘
              └────────┘          └─────────────┘ no coincide
                  │ no           coincide │
                  ▼                       ▼
      ┌─────────────────────────┐ ┌─────────────┐
      │terminar sin coincidencia│ │terminar, la │
      └─────────────────────────┘ │ruta coincide│
                                  └─────────────┘
    #+END_EXAMPLE

    =buscar regexp=: diseño actual

    #+BEGIN_EXAMPLE
                    ┌──────────────────┐
                    │ guardar posicion │                                 ┏━━━━━━━━━━━━━┓
                    └──────────────────┘                                 ┃buscar regexp┃
               ┌────────────▶│                                           ┗━━━━━━━━━━━━━┛
               │             ▼
               │      ┌───────────────┐
               │      │recorrer rutas │
               │      └───────────────┘
               │             │                         ┌─────────────────────────────────┐
               │             ▼                         ▼                                 │
               │         ┌────────┐   si     ┌───────────────────┐                       │
               │        <│hay ruta│>────────▶│obtener constructor│                       │
               │         └────────┘          └───────────────────┘                       │
               │             │ no                      │                                 │
               │             ▼                         ▼                                 │
               │ ┌─────────────────────────┐   ┌───────────────┐  no  ┌─────────────┐    │
               │ │terminar sin coincidencia│  <│hay constructor│>────▶│terminar: la │    │
               │ └─────────────────────────┘   └───────────────┘      │ruta coincide│    │
               │                                       │ si           └─────────────┘    │
               │                    ┌────────┬─────────┼───────────┬──────────┐          │
               │                    ▼        ▼         ▼           ▼          ▼          │
      ┌──────────────────┐      ┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐    │
      │restaurar posicion│      │conjunto││punto││metacaracter││caracter││agrupacion│    │
      └──────────────────┘      └────────┘└─────┘└────────────┘└────────┘└──────────┘    │
               ▲                    │        │         │           │          │          │
               │                    └────────┴─────────┼───────────┘          │          │
               │                                       ▼                      ▼          │
       ┌────────────────┐    no coincide     ┌──────────────────┐      ┌─────────────┐   │
       │terminar: ruta  │◀────────┬─────────<│buscar constructor│>  ┌─<│buscar regexp│>  │
       │sin coincidencia│         │          └──────────────────┘   │  └─────────────┘   │
       └────────────────┘         │                    │ coincide   │         │          │
                                  └──────────────────┈┈│┈┈──────────┘         │ coincide │
                                                       ▼                      │          │
                                              ┌──────────────────┐            └──────────┤
                                              │avanzar por cadena│                       │
                                              └──────────────────┘                       │
                                                       │                                 │
                                                       └─────────────────────────────────┘
    #+END_EXAMPLE

* Benchmarks

  Se eligieron los sigientes motores como punto de comparacion:

  - [[http://www.pcre.org/][PCRE2 10.10]]
  - [[https://github.com/laurikari/tre/][tre 0.8.0]]
  - [[http://www.geocities.jp/kosako3/oniguruma/][Oniguruma 5.9.6]]
  - [[https://github.com/google/re2][re2 by Google]]
  - [[http://sljit.sourceforge.net/pcre.html][PCRE2 10.10 with sljit JIT compiler support]]


  vs el Raptor ([[https://github.com/nasciiboy/RecursiveRegexpRaptor][regexp3_ascii.c]] & [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4_ascii.c]])

** Results
*** x86-64 bit Intel Cerelon 847 1.1GHz (GCC 6.3.1, GNU/Linux)

    #+BEGIN_HTML
      <table class="results" border="1" width="100%">
      <tbody><tr><th>Regular expression</th><th>PCRE</th><th>PCRE<br>-DFA</th><th>TRE</th><th>Onig-<br>uruma</th><th>RE2</th><th>PCRE<br>-JIT</th><th class="raptor3">regexp3</th><th class="raptor4">regexp4</th></tr>
      <tr><td class="pattern"><table><tr><td>.|\n</td></tr><tr><td class="raptor3-pattern">.</td></tr></table></td><td class="time">4514 ms (20045118)</td><td class="time">5320 ms (20045118)</td><td class="time">6500 ms (20045118)</td><td class="time">13378 ms (20045118)</td><td class="time">10619 ms (20045118)</td><td class="time">1086 ms (20045118)</td><td class="time">1768 ms (20045118)</td><td class="time">748 ms (20045118)</td></tr>
      <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptor3-pattern">:w</td></tr></table></td><td class="time">3893 ms (14751878)</td><td class="time">3026 ms (14751878)</td><td class="time">4604 ms (14751878)</td><td class="time">10947 ms (14751878)</td><td class="time">7967 ms (14751878)</td><td class="time">944 ms (14751878)</td><td class="time">1836 ms (14750958)</td><td class="time">941 ms (14750958)</td></tr>
      <tr><td class="pattern"><table><tr><td>\d</td></tr><tr><td class="raptor3-pattern">:d</td></tr></table></td><td class="time">65 ms (27084)</td><td class="time">67 ms (27084)</td><td class="time">1036 ms (27084)</td><td class="time">150 ms (27084)</td><td class="time">153 ms (27084)</td><td class="time">57 ms (27084)</td><td class="time">1807 ms (27084)</td><td class="time">608 ms (27084)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S</td></tr><tr><td class="raptor3-pattern">:S</td></tr></table></td><td class="time">3023 ms (15451664)</td><td class="time">3130 ms (15451664)</td><td class="time">4533 ms (15451664)</td><td class="time">10776 ms (15451664)</td><td class="time">8273 ms (15451664)</td><td class="time">902 ms (15451664)</td><td class="time">1846 ms (15451664)</td><td class="time">958 ms (15451664)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S+</td></tr><tr><td class="raptor3-pattern">:S+</td></tr></table></td><td class="time">918 ms (3414592)</td><td class="time">1587 ms (3414592)</td><td class="time">2462 ms (3414592)</td><td class="time">3019 ms (3414592)</td><td class="time">2183 ms (3414592)</td><td class="time">320 ms (3414592)</td><td class="time">1078 ms (3414592)</td><td class="time">713 ms (3414592)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]+</td></tr><tr><td class="raptor3-pattern">[a-zA-Z]+</td></tr></table></td><td class="time">973 ms (3495761)</td><td class="time">1540 ms (3495761)</td><td class="time">2282 ms (3495761)</td><td class="time">2919 ms (3495761)</td><td class="time">2258 ms (3495761)</td><td class="time">333 ms (3495761)</td><td class="time">3301 ms (3495761)</td><td class="time">1134 ms (3495761)</td></tr>
      <tr><td class="pattern"><table><tr><td>[.\s]+</td></tr><tr><td class="raptor3-pattern">[:.:s]+</td></tr><tr><td class="raptor4-pattern">[.:s]+</td></tr></table></td><td class="time">915 ms (3430783)</td><td class="time">1047 ms (3430783)</td><td class="time">1888 ms (991813)</td><td class="time">2799 ms (3430783)</td><td class="time">2241 ms (3430783)</td><td class="time">379 ms (3430783)</td><td class="time">4203 ms (3430783)</td><td class="time">1395 ms (3430783)</td></tr>
      <tr><td class="pattern"><table><tr><td>([^\n]+)</td></tr><tr><td class="raptor3-pattern">&lt;[^\n]+&gt;</td></tr></table></td><td class="time">308 ms (314387)</td><td class="time">1179 ms (314387)</td><td class="time">1504 ms (314387)</td><td class="time">741 ms (314387)</td><td class="time">477 ms (314387)</td><td class="time">88 ms (314387)</td><td class="time">1267 ms (314387)</td><td class="time">597 ms (314387)</td></tr>
      <tr><td class="pattern"><table><tr><td>e</td></tr><tr><td class="raptor3-pattern">e</td></tr></table></td><td class="time">373 ms (1781425)</td><td class="time">453 ms (1781425)</td><td class="time">501 ms (1781425)</td><td class="time">1448 ms (1781425)</td><td class="time">1019 ms (1781425)</td><td class="time">135 ms (1781425)</td><td class="time">1757 ms (1781425)</td><td class="time">704 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>(((((e)))))</td></tr><tr><td class="raptor3-pattern">&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1289 ms (1781425)</td><td class="time">1153 ms (1781425)</td><td class="time">494 ms (1781425)</td><td class="time">1879 ms (1781425)</td><td class="time">1016 ms (1781425)</td><td class="time">210 ms (1781425)</td><td class="time">17686 ms (1781425)</td><td class="time">3485 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>((((((((((e))))))))))</td></tr><tr><td class="raptor3-pattern">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">2019 ms (1781425)</td><td class="time">1727 ms (1781425)</td><td class="time">494 ms (1781425)</td><td class="time">2121 ms (1781425)</td><td class="time">1037 ms (1781425)</td><td class="time">296 ms (1781425)</td><td class="time">48633 ms (1781425)</td><td class="time">5147 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>Twain</td></tr><tr><td class="raptor3-pattern">Twain</td></tr></table></td><td class="time">10 ms (2388)</td><td class="time">49 ms (2388)</td><td class="time">993 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">2383 ms (2388)</td><td class="time">614 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Twain)</td></tr><tr><td class="raptor3-pattern">&lt;Twain&gt;</td></tr></table></td><td class="time">14 ms (2388)</td><td class="time">49 ms (2388)</td><td class="time">987 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">5299 ms (2388)</td><td class="time">999 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?i)Twain</td></tr><tr><td class="raptor3-pattern">#*Twain</td></tr></table></td><td class="time">192 ms (2657)</td><td class="time">287 ms (2657)</td><td class="time">1253 ms (2657)</td><td class="time">345 ms (2657)</td><td class="time">179 ms (2657)</td><td class="time">52 ms (2657)</td><td class="time">2512 ms (2657)</td><td class="time">781 ms (2657)</td></tr>
      <tr><td class="pattern"><table><tr><td>((T|t)([wW])(a|A)i?I?([nN]))</td></tr><tr><td class="raptor3-pattern">&lt;&lt;T|t&gt;&lt;[wW]&gt;&lt;a|A&gt;i?I?&lt;[nN]&gt;&gt;</td></tr></table></td><td class="time">577 ms (2658)</td><td class="time">458 ms (2658)</td><td class="time">1750 ms (2658)</td><td class="time">361 ms (2658)</td><td class="time">179 ms (2658)</td><td class="time">76 ms (2658)</td><td class="time">17773 ms (2658)</td><td class="time">2565 ms (2658)</td></tr>
      <tr><td class="pattern"><table><tr><td>(T+([w]?(a{1}(i+(n*))))){1}</td></tr><tr><td class="raptor3-pattern">&lt;T+&lt;[w]?&lt;a{1}&lt;i+&lt;n*&gt;&gt;&gt;&gt;&gt;{1}</td></tr></table></td><td class="time">25 ms (2419)</td><td class="time">60 ms (2419)</td><td class="time">1175 ms (2419)</td><td class="time">164 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">7 ms (2419)</td><td class="time">12277 ms (2419)</td><td class="time">1025 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?:T+(?:[w]?(?:a{1}(?:i+(?:n*))))){1}</td></tr><tr><td class="raptor3-pattern">(T+([w]?(a{1}(i+(n*))))){1}</td></tr></table></td><td class="time">22 ms (2419)</td><td class="time">60 ms (2419)</td><td class="time">1155 ms (2419)</td><td class="time">159 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">7 ms (2419)</td><td class="time">12149 ms (2419)</td><td class="time">943 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-z]shing</td></tr><tr><td class="raptor3-pattern">[a-z]shing</td></tr></table></td><td class="time">1456 ms (1877)</td><td class="time">2308 ms (1877)</td><td class="time">1559 ms (1877)</td><td class="time">50 ms (1877)</td><td class="time">290 ms (1877)</td><td class="time">48 ms (1877)</td><td class="time">5759 ms (1877)</td><td class="time">1319 ms (1877)</td></tr>
      <tr><td class="pattern"><table><tr><td>Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr><tr><td class="raptor3-pattern">Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr></table></td><td class="time">72 ms (396)</td><td class="time">75 ms (396)</td><td class="time">1569 ms (396)</td><td class="time">139 ms (396)</td><td class="time">139 ms (396)</td><td class="time">8 ms (396)</td><td class="time">6612 ms (396)</td><td class="time">1554 ms (396)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-q][^u-z]{13}x</td></tr><tr><td class="raptor3-pattern">[a-q][^u-z]{13}x</td></tr></table></td><td class="time">1731 ms (4929)</td><td class="time">6363 ms (4929)</td><td class="time">4285 ms (4929)</td><td class="time">157 ms (4929)</td><td class="time">569 ms (4929)</td><td class="time">5 ms (4929)</td><td class="time">11654 ms (4929)</td><td class="time">3600 ms (4929)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom|Sawyer|Huckleberry|Finn</td></tr><tr><td class="raptor3-pattern">Tom|Sawyer|Huckleberry|Finn</td></tr></table></td><td class="time">96 ms (3015)</td><td class="time">100 ms (3015)</td><td class="time">2749 ms (3015)</td><td class="time">161 ms (3015)</td><td class="time">143 ms (3015)</td><td class="time">84 ms (3015)</td><td class="time">10422 ms (3015)</td><td class="time">2803 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Tom|Sawyer|Huckleberry|Finn)</td></tr><tr><td class="raptor3-pattern">&lt;Tom|Sawyer|Huckleberry|Finn&gt;</td></tr></table></td><td class="time">101 ms (3015)</td><td class="time">103 ms (3015)</td><td class="time">2767 ms (3015)</td><td class="time">162 ms (3015)</td><td class="time">143 ms (3015)</td><td class="time">82 ms (3015)</td><td class="time">19118 ms (3015)</td><td class="time">3172 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr><tr><td class="raptor3-pattern">[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr></table></td><td class="time">631 ms (534)</td><td class="time">879 ms (534)</td><td class="time">2914 ms (534)</td><td class="time">690 ms (534)</td><td class="time">263 ms (534)</td><td class="time">241 ms (534)</td><td class="time">12257 ms (534)</td><td class="time">1586 ms (534)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom.{10,25}river|river.{10,25}Tom</td></tr><tr><td class="raptor3-pattern">Tom([^(river|\n)]){10,25}river|river([^(Tom|\n)]){10,25}Tom</td></tr><tr><td class="raptor4-pattern">Tom(river|\n){10,25}#!river|river(Tom|\n){10,25}#!Tom</td></tr></table></td><td class="time">204 ms (2)</td><td class="time">248 ms (2)</td><td class="time">1762 ms (2)</td><td class="time">250 ms (2)</td><td class="time">238 ms (2)</td><td class="time">45 ms (2)</td><td class="time">12620 ms (2)</td><td class="time">1583 ms (2)</td></tr>
      <tr><td class="pattern"><table><tr><td>ing[^a-zA-Z]</td></tr><tr><td class="raptor3-pattern">ing[^a-zA-Z]</td></tr></table></td><td class="time">140 ms (85956)</td><td class="time">242 ms (85956)</td><td class="time">1104 ms (85956)</td><td class="time">141 ms (85956)</td><td class="time">113 ms (85956)</td><td class="time">54 ms (85956)</td><td class="time">3159 ms (85956)</td><td class="time">657 ms (85956)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]ing[^a-zA-Z]</td></tr><tr><td class="raptor3-pattern">[a-zA-Z]ing[^a-zA-Z]</td></tr></table></td><td class="time">1499 ms (85823)</td><td class="time">2383 ms (85823)</td><td class="time">1797 ms (85823)</td><td class="time">142 ms (85823)</td><td class="time">326 ms (85823)</td><td class="time">57 ms (85823)</td><td class="time">7701 ms (85823)</td><td class="time">1392 ms (85823)</td></tr>
      <tr><td class="pattern"><table><tr><td>([a-zA-Z]+ing)</td></tr><tr><td class="raptor3-pattern">&lt;([^(ing|:A)])+ing(([^(ing|:A)])*ing)*&gt;</td></tr><tr><td class="raptor4-pattern">&lt;(ing|:A)+#!ing((ing|:A)*#!ing)*&gt;</td></tr></table></td><td class="time">4018 ms (95863)</td><td class="time">5394 ms (95863)</td><td class="time">2096 ms (95863)</td><td class="time">2513 ms (95863)</td><td class="time">344 ms (95863)</td><td class="time">222 ms (95863)</td><td class="time">51980 ms (95863)</td><td class="time">7888 ms (95863)</td></tr>
      </tbody></table>
    #+END_HTML

    El entorno de pruebas [[https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks][aqui]] (El entorno fue creado por [[https://sourceforge.net/u/dark100/profile/][dark100]] puede
    descargalo desde [[http://sljit.sourceforge.net/regex-test.tgz][aqui]]). Solo descargalo, escribe =make= y ejecuta =runtest=.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y acorde a
  ello se utiliza la licencia GNU GPL Version 3. Cualquier obra que incluya o
  derive codigo de esta libreria, debera cumplir con los terminos de esta
  licencia.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
