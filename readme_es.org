#+TITLE:    Recursive Regexp Raptor (regexp3)
#+AUTHOR:   nasciiboy
#+LANGUAGE: es
#+STARTUP:  showall

lang: [[file:readme.org][en]]

regexp3 ([[https://github.com/nasciiboy/RecursiveRegexpRaptor][C-lang]], [[https://github.com/nasciiboy/regexp3][Go-lang]]) and regexp4 ([[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][C-lang]], [[https://github.com/nasciiboy/regexp4][Go-lang]])

raptor-book (borrador) : [[https://github.com/nasciiboy/raptor-book/][aqui]]

* Caracteristicas

  - Manejo sencillo,

  - Sin verificacion de errores.

  - Solo expresiones regulares

  - El codigo mas compacto y claro que alla precenciado nunca antes
    alguna libreria regexp humana.

  - Cero dependencias. Ni la libreria estandar de C esta precente *C PURO*.

  - Manejo no explicito de memoria dinamica. Ningun =malloc=, =calloc=, =free=,
    ...

  - Conteo de coincidencias

  - Capturas

  - Reemplazo de capturas

  - Colocacion de capturas especificas dentro de un arreglo

  - Negacion de expreciones (experimental)

  - Referencia dentro de la exprecion a capturas previas

  - Soporte UTF8

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y reemplazo de
  expresiones regulares escrita en lenguaje C desce cero, intentando lograr lo
  siguiente:

  - Contar con la mayoria de caracteristicas presentes en cualquier otra
    libreria regexp.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar la peticion explicita de memoria dinamica.

  - Evitar el uso de ninguna libreria externa, incluida la libreria estandar.

  - Ser util como material de aprendizaje.


  Existen dos desarrollos paralelos de esta libreria el primero (el presente) se
  centra en la simplicidad y el codigo, el segundo aun en fase beta ([[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4]])
  intenta alcanzar la maxima velocidad posible implemetando una "tabla de
  instrucciones". En ambos casos el algoritmo parte de cero, y solo se hace uso
  de C tal cual, enjoy!

** Motivacion

   C no dispone de una libreria estandar de expresiones regulares, si bien
   existen varias implementaciones, como pcre, la libreria regexp.h del proyecto
   GNU, regexp del sistema operativo Plan 9, y algunas otras mas, el autor de
   este trabajo (que igual y es un poco retard) encontro en todas codigo
   rebuscado y mistico repartido en varios ficheros, llenos de macros, guiones
   bajos y variables cripticas. Incapas de entender nada y tras un retiro a la
   isla de la meditacion onanista el autor se propuso hacer su propia libreria
   con casinos y colegialas japonesas.

** Desarrollo y pruebas

   Se ha utilizado GNU Emacs (el unico y verdadero sistema operativo), los
   compiladores gcc (6.3.1) y clang (LLVM) 3.8.1, konsole y fish, corriendo en
   Freidora 25.

   existen dos pruebas para la libreria, la primera es una bateria de pruebas
   ascii en el fichero =ascii_test.c=.

   para probar la vercion ascii de la libreria

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_ascii.c
   #+END_SRC

   para la vercion UTF8

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_utf8.c
   #+END_SRC

   la segunda bateria de pruebas es exclusiva de =regexp3_utf8.c=

   #+BEGIN_SRC sh
     gcc utf8_test.c regexp3_utf8.c
   #+END_SRC

   en cualquiera de los casos ejecute con

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  Para incluir Recursive Regexp Raptor en su codigo necesita colocar los
  ficheros =regexp3.h=, =charUtils.h= y de pendiendo del caso de uso
  =regexp3_ascii.c= o =regexp3_utf8.c= dentro de la carpeta de su
  proyecto. Debe incluir el encabezado

  #+BEGIN_SRC c
    #include "regexp3.h"
  #+END_SRC

  y por ultimo compilar bien con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_ascii.c
  #+END_SRC

  o con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_utf8.c
  #+END_SRC

  obviamente, compilar con optimizacion proporciona una disminucion drastica del
  tiempo de ejecucion, intente con =-O3=

** funcion =regexp3()=

   Esta es la unica funcion de busqueda, aqui su prototipo:

   #+BEGIN_SRC c
     int regexp3( const char *txt, const char *re );
   #+END_SRC

   - txt  :: apuntador a cadena sobre la que efectuar la busqueda, debe
             finalizar con el signo de terminacion '\0'.

   - re   :: apuntador a cadena que contiene la expresion regular de busqueda,
             debe finalizar con el signo de terminacion '\0'.


   La funcion regresa el numero de coincidencias =0= (ninguna) o =n=
   coincidencias.

   La sintaxis estandar para expresiones regulares utiliza el caracter '=\=',
   lamentablemente este signo entra en "conflicto" con la sintaxis de C, por
   esto e intentando mantener el codigo lo mas sencillo, se ha optado por una
   sintaxis alterna detallada a continuacion

** Sintaxis

   - busqueda de texto en cualquier ubicacion:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Raptor" );
     #+END_SRC

   - multiples opciones de busqueda "exp1|exp2"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Dinosaur|T Rex|Raptor|Triceratops" );
     #+END_SRC

   - coincidencia con cualquier caracter '.'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R.ptor" );
     #+END_SRC

   - coincidencia cero o una ves '?'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra?ptor" );
     #+END_SRC

   - coincidencia una o mas veces '+'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra+ptor" );
     #+END_SRC

   - coincidencia cero o mas veces '*'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra*ptor" );
     #+END_SRC

   - rango de coincidencias "{n1,n2}"

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{0,100}ptor" );
     #+END_SRC

   - numero de coincidencias especifico '{n1}'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra{1}ptor" );
     #+END_SRC

   - numero minimo de coincidencias '{n1,}'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{1,}ptor" );
     #+END_SRC

   - Conjuntos.

     - Conjunto de caracteres "[abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[uoiea]ptor" );
       #+END_SRC

     - Rango dentro de un conjunto de caracteres "[a-b]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[a-z]ptor" );
       #+END_SRC

     - Metacaracter dentro de un conjunto de caracteres "[:meta]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[:w]ptor" );
       #+END_SRC

     - inversion de conjunto de caracteres  "[^abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[^uoie]ptor" );
       #+END_SRC

   - caracteres con codificacion utf8

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R△ptor" );
     #+END_SRC

     tambien

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R[△]ptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una letra ":a"

     #+BEGIN_SRC c
       regexp3( "RAptor Test", "R:aptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea una letra ":A"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Aptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una numero ":d"

     #+BEGIN_SRC c
       regexp3( "R4ptor Test", "R:dptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un numero ":D"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Dptor" );
     #+END_SRC

   - coincidencia con un caracter alfanumerico ":w"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:wptor" );
     #+END_SRC

   - coincidencia con un caracter no alfanumerico ":W"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Wptor" );
     #+END_SRC

   - coincidencia con un caracter que sea un espacio ":s"

     #+BEGIN_SRC c
       regexp3( "R ptor Test", "R:sptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un espacio ":S"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Sptor" );
     #+END_SRC

   - coincidencia con un caracter utf8 ":&"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:&ptor" );
     #+END_SRC

   - escape de caracteres con significado especial ":caracter"

     los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*', '{', '}',
     '-', '#' y '@' indican como debe procesarse la exprecion regular, colocar
     alguno de estos caracteres tal cual, sin tener en cuenta una correcta
     sintaxis dentro de la exprecion, puede generar bucles infinitos al igual
     que errores por violacion de segmento.

     #+BEGIN_SRC c
       regexp3( ":#()|<>", ":::#:(:):|:<:>" );
     #+END_SRC

     los caracteres /especiales/ (exepto el metacarater =:=) pierden su
     significado detro de un conjunto

     #+BEGIN_SRC c
       regexp3( "()<>[]|{}*#@?+", "[()<>:[:]|{}*?+#@]" );
     #+END_SRC

   - agrupacion "(exp)"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "(Raptor)" );
     #+END_SRC

   - agrupacion con captura "<exp>"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "<Raptor>" );
     #+END_SRC

   - backreferences "@id"

     las referencias necesitan que previamente se halla capturado una exprecion
     mediante "<exp>", luego se coloca el numero de aparicion de la captura
     precidido por '@'

     #+BEGIN_SRC c
       regexp3( "ae_ea", "<a><e>_@2@1" )
     #+END_SRC

   - modificadores de comportamiento

     Existen dos tipos de modificadores. El primero afecta de forma global el
     comportamiento de la exprecion, el segundo afecta secciones en
     especifico. En ambos caso los la sintaxis es la misma, el signo '#',
     seguido por los modificadores,

     los modificadores de alcance global se coloca al inicio, de toda la
     exprecion y son los siguientes

     - busqueda solo al inicio '#^exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^Raptor" );
       #+END_SRC

     - busqueda solo al final '#$exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#$Test" );
       #+END_SRC

     - busqueda al inicio y final "#^$exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^$Raptor Test" );
       #+END_SRC

     - detener con la primer coincidencia "#?exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#?Raptor Test" );
       #+END_SRC

     - buscar por la cadena caracter a caracter "#~"

       de forma predeterminada cuando una exprecion coincide con una region del
       texto de busqueda, la busqueda prosigue a partir del final de dicha
       coincidencia, para ignorar este comportamiento, haciendo que la busqueda
       siempre sea caracter a caracter se utiliza este modificador

       #+BEGIN_SRC c
         regexp3( "aaaaa", "#~a*" );
       #+END_SRC

       en este ejemplo, sin el modificador el resultado seria una coincidencia,
       sin embargo con este modificador la busqueda continua inmediatamente
       despues del siguente caracter regresando cinco coincidencias.

     - ignorar entre minusculas y mayusculas "#*exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#*RaPtOr TeSt" );
       #+END_SRC


     todos los modificadores anteriores son compatibles entre si es decir podria
     buscar

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#^$*?~RaPtOr TeSt" );
     #+END_SRC

     sin embargo los  modificadores  '~' y '?' pierden sentido debido a la
     presencia de '^' y/o '$'.

     una exprecion del tipo:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#$RaPtOr|#$TeSt" );
     #+END_SRC

     es erronea, el modificador despues del '|' se aplicaria la seccion entre
     '|' y '#', es decir cero, con un retorno de erroneo

     los modificadores locales se colocan despues del indicador de repeticion
     (de existir) y afectan la misma region que afectan los indicadores de
     repeticion, es decir caracteres, conjuntos o agrupaciones.

     - ignorar entre minusculas y mayusculas "exp#*"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "(RaPtOr)#* TeS#*t" );
       #+END_SRC

     - no ignorar entre minusculas y mayusculas "exp#/"

       #+BEGIN_SRC c
         regexp3( "RaPtOr TeSt", "#*(RaPtOr)#/ TES#/T" );
       #+END_SRC

     - *negacion de exprecion* "exp#!"

       esta poco convencional exprecion permite el equivalente en otras
       librerias a expreciones tipo

       #+BEGIN_SRC c
         xx.*yy
       #+END_SRC

       es decir "xx" seguida por cualquier cosa que no sea "yy", seguida por "yy".
       En esta sintaxis seria

       #+BEGIN_SRC c
         regexp3( "xx123456789yy", "xx(yy)*#!yy" );
       #+END_SRC

** Capturas

   Las capturas se indexan segun el orden de aparicion dentro de la expresion
   por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion coincide mas de una ocacion dentro del texto de busqueda el
   indice, se incrementa segun su aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     coincidencia uno         coincidencia dos         coincidencia tres
   #+END_EXAMPLE

   la funcion =cpytCatch= hace una copia de una la captura dentro de un arreglo
   de caracteres, aqui su prototipo:

   #+BEGIN_SRC c
     char * cpyCatch( char * str, const int index )
   #+END_SRC

   - str   :: puntero lo suficientemete grande para contener la captura.

   - index :: indice de la agrupacion (de =1= a =n=).


   la funcion regeresa un apuntador a la captura terminada en '\0'. Un indice
   incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero capturadas dentro de una busqueda, utlice
   =totCatch=:

   #+BEGIN_SRC c
     int totCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=.

   Podria utilzar esta y la anterior funcion para imprimir las capturadas con
   una funcion como esta:

   #+BEGIN_SRC c
     void printCatch(){
       char str[128];
       int i = 0, max = totCatch();

       while( ++i <= max )
         printf( "[%d] >%s<\n", i, cpyCatch( str, i ) );
     }
   #+END_SRC

*** =gpsCatch()= y =lenCatch()=

    las funciones =gpsCatch()= y =lenCatch()= realizan la misma labor que
    =cpyCatch= con la variante de no utilizar un arreglo, en su lugar la primera
    regresa un puntero a la posicion inicial de la captura dentro del texto de
    busqueda y la segunda regresa la longitud de dicha captura.

    #+BEGIN_SRC c
      int          lenCatch( const int index );
      const char * gpsCatch( const int index );
    #+END_SRC

    el ejemplo anterior con estas fuciones, seria:

    #+BEGIN_SRC c
      void printCatch(){
        int i = 0, max = totCatch();

        while( ++i <= max )
          printf( "[%d] >%.*s<\n", i, lenCatch( i ), gpsCatch( i ) );
      }
    #+END_SRC

*** Colocar capturas dentro de una cadena

    #+BEGIN_SRC c
      char * putCatch( char * newStr, const char * putStr );
    #+END_SRC

    el argumento =putStr= contiene el texto con el cual formar la nueva cadena
    asi como indicadores de cuales capturas colocar. Para indicar la insercion
    de una captura coque el signo '#' seguido del indice de captura. por ejemplo
    el argumento =putStr= podria ser

    #+BEGIN_SRC c
      char *putStr = "captura 1 >>#1<< captura 2 >>#2<< captura 747 >>#747<<";
    #+END_SRC

    =newStr= es un arreglo de caracteres lo suficientemente grande como para
    contener la cadena + las capturas. la funcion regresa un apuntador a la
    posicion inicial de este arreglo, que finaliza con el signo de terminacion
    '\0'.

    para colocar el caracter '#' dentro de la cadena escape '#' con un '#'
    adicional, es decir:

    #+BEGIN_EXAMPLE
      "## comentario"  -> "# comentario"
    #+END_EXAMPLE

*** Reemplazar una captura

    El reemplazo opera sobre un arreglo de caracteres en el cual se coloca el
    texto de busqueda modificando una captura especifica por una cadena de
    texto, la funcion encargada de esta labor es =rplCatch=, su prototipo es:

    #+BEGIN_SRC c
      char * rplCatch( char * newStr, const char * rplStr, const int id );
    #+END_SRC

    - newStr :: arreglo de caracteres de dimension dende se colocara el texto
                original sobre el que se efectua y el texto de reemplazo de las
                capturas.

    - rplStr :: texto de reemplazo para captura.

    - id     :: *identificador* de captura segun el orden de aparicion dentro de
                la exprecion regular. Pasar un indice incorrecto, coloca una
                copia sin modificacion de la cadena de busqueda sobre el arreglo
                =newStr=.


    en este caso el uso del argumento =id= a diferencia de la funcion =getCatch=
    no se refiere a una "captura" en especifico, es decir no importa la cantidad
    de ocaciones que se ha capturado una exprecion, el identificador indica la
    *posicion* dentro de la exprecion en si, es decir:

    #+BEGIN_EXAMPLE
         <   <   >  | <   <   >   >   >
      id = 1 ==========================
      id     = 2==    = 2 =========
      id                  = 3 =
      posicion de la captura dentro de la exprecion
    #+END_EXAMPLE

    la modificacion afecta de este modo

    #+BEGIN_EXAMPLE
      <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
      = 1 ==================       = 1 ==================      = 1 ==================
          = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
      captura uno                  "..." dos                   "..." tres
    #+END_EXAMPLE

** Metacaracteres de busqueda

   - =:d= :: dígito del 0 al 9.
   - =:D= :: cualquier carácter que no sea un dígito del 0 al 9.
   - =:a= :: cualquier caracter que sea una letra (a-z,A-Z)
   - =:A= :: cualquier caracter que no sea una letra
   - =:w= :: cualquier carácter alfanumérico.
   - =:W= :: cualquier carácter no alfanumérico.
   - =:s= :: cualquier caracter de espacio en blanco.
   - =:S= :: cualquier carácter que no sea un espacio en blanco.
   - =:&= :: caracter no ascii (solo en version UTF8).

   - =:|= :: barra vertical
   - =:^= :: acento circunflejo
   - =:$= :: signo dolar
   - =:(= :: parentesis izquierdo
   - =:)= :: parentesis derecho
   - =:<= :: mayor que
   - =:>= :: menor que
   - =:[= :: corchete izquierdo
   - =:]= :: corchete derecho
   - =:.= :: punto
   - =:?= :: interrogacion
   - =:+= :: mas
   - =:-= :: menos
   - =:*= :: asterisco
   - =:{= :: llave izquierda
   - =:}= :: llave derecha
   - =:#= :: modificador
   - =::= :: dos puntos


   adicionalmente utilice la sintaxis propia de c para colocar caracteres como
   nueva linea, tabulador, campana,..., etc. De igual forma puede utilizar la
   sintaxis c para "colocar" caracteres en notacion octal, hexadecimal o
   unicode.

** algunos ejemplos de uso

   El fichero =ascii_test.c= contiene una amplia variedad de pruebas que son
   utiles como ejemplos de uso, entre estos se encuentran los siguentes:

   #+BEGIN_SRC c
     regexp3( "07-07-1777", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>" );
   #+END_SRC

   captura una cadena con formato de fecha, de forma separada dia, separador,
   mes y año. El separador tiene que coincider las dos ocaciones que aparece

   #+BEGIN_SRC c
      regexp3( "https://en.wikipedia.org/wiki/Regular_expression", "(https?|ftp):://<[^:s/:<:>]+></[^:s:.:<:>,/]+>*<.>*" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "<mail>nasciiboy@gmail.com</mail>", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><:.[A-Za-z0-9]{2}>*" );
   #+END_SRC

   capturar por secciones (usuario,sitio,dominio) algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "xx0123yy", "<xx><yy>*#!<yy>" );
   #+END_SRC

   capturar una cadena que contenga "xx", luego captura cualquier cosa que no
   sea "yy" y finalmente captura nuevamente "yy"

* Hacking
** algoritmo
*** Diagrama de flujo

    Esta diagrama es una aproximacion del funcionimento del motor, los nombres no
    se corresponden con los nombres del codigo, para una explicacion completa
    revisar el [[https://github.com/nasciiboy/raptor-book/][libro]]

    #+BEGIN_EXAMPLE
          ┌──────┐
          │inicio│
          └──────┘
              │◀───────────────────────────────────┐
              ▼                                    │
      ┌────────────────┐                           │
      │bucle por cadena│                           │
      └────────────────┘                           │
              │                                    │
              ▼                                    │
       ┌─────────────┐  no   ┌─────────────┐       │
      <│fin de cadena│>────▶<│buscar regexp│>──────┘
       └─────────────┘       └─────────────┘  no coincide
              │ si                  │ coincide
              ▼                     ▼
      ┌────────────────┐    ┌────────────────┐
      │informar: no    │    │informar:       │
      │hay coincidencia│    │hay coincidencia│
      └────────────────┘    └────────────────┘
              │                     │
              │◀────────────────────┘
              ▼
            ┌───┐
            │fin│
            └───┘
    #+END_EXAMPLE

    En esta version de @c(buscar regexp) todos los constructores se optienen por
    una sola funcion:

    #+BEGIN_EXAMPLE
                                                                  ┌───────────────────────────────┐
      ┏━━━━━━━━━━━━━┓                                             ▼                               │
      ┃buscar regexp┃                                   ┌───────────────────┐                     │
      ┗━━━━━━━━━━━━━┛                                   │Optener constructor│                     │
                                                        └───────────────────┘                     │
                                                                  │                               │
                                                                  ▼                               │
                                                          ┌───────────────┐  no  ┌─────────────┐  │
                                                         <│hay constructor│>────▶│terminar: la │  │
                                                          └───────────────┘      │ruta coincide│  │
                                                                  │ si           └─────────────┘  │
                                    ┌──────────┬────────┬─────────┼───────────┬──────────┐        │
                                    ▼          ▼        ▼         ▼           ▼          ▼        │
                              ┌───────────┐┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐  │
                              │alternacion││conjunto││punto││metacaracter││caracter││agrupacion│  │
                              └───────────┘└────────┘└─────┘└────────────┘└────────┘└──────────┘  │
                                    │          │        │         │           │          │        │
                                    ▼          └────────┴─────────┼───────────┘          └────────┤
                             ┌──────────────────┐                 │                               │
                  ┌──────────│ guardar posicion │                 ▼               no              │
                  │          └──────────────────┘       ┌──────────────────┐   coincide           │
                  │          ┌──────────────────┐      <│buscar constructor│>─────────┐           │
                  ▼◀─────────│restaurar posicion│◀──┐   └──────────────────┘          │           │
           ┌───────────────┐ └──────────────────┘   │             │ coincide          │           │
           │recorrer rutas │                        │             ▼                   ▼           │
           └───────────────┘                        │    ┌──────────────────┐ ┌────────────────┐  │
                  │                                 │    │avanzar por cadena│ │terminar, ruta  │  │
                  ▼                                 │    └──────────────────┘ │sin coincidencia│  │
              ┌────────┐   si     ┌─────────────┐   │             │           └────────────────┘  │
             <│hay ruta│>───────▶<│buscar regexp│>──┘             └───────────────────────────────┘
              └────────┘          └─────────────┘ no coincide
                  │ no           coincide │
                  ▼                       ▼
      ┌─────────────────────────┐ ┌─────────────┐
      │terminar sin coincidencia│ │terminar, la │
      └─────────────────────────┘ │ruta coincide│
                                  └─────────────┘
    #+END_EXAMPLE

    =buscar regexp=: diseño actual

    #+BEGIN_EXAMPLE
                    ┌──────────────────┐
                    │ guardar posicion │                                 ┏━━━━━━━━━━━━━┓
                    └──────────────────┘                                 ┃buscar regexp┃
               ┌────────────▶│                                           ┗━━━━━━━━━━━━━┛
               │             ▼
               │      ┌───────────────┐
               │      │recorrer rutas │
               │      └───────────────┘
               │             │                         ┌─────────────────────────────────┐
               │             ▼                         ▼                                 │
               │         ┌────────┐   si     ┌───────────────────┐                       │
               │        <│hay ruta│>────────▶│obtener constructor│                       │
               │         └────────┘          └───────────────────┘                       │
               │             │ no                      │                                 │
               │             ▼                         ▼                                 │
               │ ┌─────────────────────────┐   ┌───────────────┐  no  ┌─────────────┐    │
               │ │terminar sin coincidencia│  <│hay constructor│>────▶│terminar: la │    │
               │ └─────────────────────────┘   └───────────────┘      │ruta coincide│    │
               │                                       │ si           └─────────────┘    │
               │                    ┌────────┬─────────┼───────────┬──────────┐          │
               │                    ▼        ▼         ▼           ▼          ▼          │
      ┌──────────────────┐      ┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐    │
      │restaurar posicion│      │conjunto││punto││metacaracter││caracter││agrupacion│    │
      └──────────────────┘      └────────┘└─────┘└────────────┘└────────┘└──────────┘    │
               ▲                    │        │         │           │          │          │
               │                    └────────┴─────────┼───────────┘          │          │
               │                                       ▼                      ▼          │
       ┌────────────────┐    no coincide     ┌──────────────────┐      ┌─────────────┐   │
       │terminar: ruta  │◀────────┬─────────<│buscar constructor│>  ┌─<│buscar regexp│>  │
       │sin coincidencia│         │          └──────────────────┘   │  └─────────────┘   │
       └────────────────┘         │                    │ coincide   │         │          │
                                  └──────────────────┈┈│┈┈──────────┘         │ coincide │
                                                       ▼                      │          │
                                              ┌──────────────────┐            └──────────┤
                                              │avanzar por cadena│                       │
                                              └──────────────────┘                       │
                                                       │                                 │
                                                       └─────────────────────────────────┘
    #+END_EXAMPLE

* Benchmarks

  Se eligieron los sigientes motores como punto de comparacion:

  - [[http://www.pcre.org/][PCRE2 10.10]]
  - [[https://github.com/laurikari/tre/][tre 0.8.0]]
  - [[http://www.geocities.jp/kosako3/oniguruma/][Oniguruma 5.9.6]]
  - [[https://github.com/google/re2][re2 by Google]]
  - [[http://sljit.sourceforge.net/pcre.html][PCRE2 10.10 with sljit JIT compiler support]]


  vs el Raptor ([[https://github.com/nasciiboy/RecursiveRegexpRaptor][regexp3_ascii.c]] & [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4_ascii.c]])

** Results
*** x86-64 bit Intel Cerelon 847 1.1GHz (GCC 6.3.1, GNU/Linux)

    #+BEGIN_HTML
      <table class="results" border="1" width="100%">
      <tr><td class="pattern"><table><tr><td>.|\n</td></tr><tr><td class="raptorPattern">.</td></tr></table></td><td class="time">4578 ms (20045118)</td><td class="time">5297 ms (20045118)</td><td class="time">6438 ms (20045118)</td><td class="time">13048 ms (20045118)</td><td class="time">10503 ms (20045118)</td><td class="time">1086 ms (20045118)</td><td class="time">1465 ms (20045118)</td><td class="time">682 ms (20045118)</td></tr>
      <tr><td class="pattern"><table><tr><td>\d</td></tr><tr><td class="raptorPattern">:d</td></tr></table></td><td class="time">66 ms (27084)</td><td class="time">67 ms (27084)</td><td class="time">1037 ms (27084)</td><td class="time">150 ms (27084)</td><td class="time">150 ms (27084)</td><td class="time">57 ms (27084)</td><td class="time">1388 ms (27084)</td><td class="time">641 ms (27084)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S</td></tr><tr><td class="raptorPattern">:S</td></tr></table></td><td class="time">3036 ms (15451664)</td><td class="time">3136 ms (15451664)</td><td class="time">4538 ms (15451664)</td><td class="time">10213 ms (15451664)</td><td class="time">8173 ms (15451664)</td><td class="time">904 ms (15451664)</td><td class="time">1494 ms (15451664)</td><td class="time">927 ms (15451664)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S+</td></tr><tr><td class="raptorPattern">:S+</td></tr></table></td><td class="time">906 ms (3414592)</td><td class="time">1595 ms (3414592)</td><td class="time">2467 ms (3414592)</td><td class="time">2855 ms (3414592)</td><td class="time">2164 ms (3414592)</td><td class="time">319 ms (3414592)</td><td class="time">1054 ms (3414592)</td><td class="time">718 ms (3414592)</td></tr>
      <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptorPattern">:w</td></tr></table></td><td class="time">2928 ms (14751878)</td><td class="time">3031 ms (14751878)</td><td class="time">4603 ms (14751878)</td><td class="time">10355 ms (14751878)</td><td class="time">7809 ms (14751878)</td><td class="time">997 ms (14751878)</td><td class="time">1500 ms (14750958)</td><td class="time">912 ms (14750958)</td></tr>
      <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptorPattern">[:w_]</td></tr></table></td><td class="time">2922 ms (14751878)</td><td class="time">3030 ms (14751878)</td><td class="time">4599 ms (14751878)</td><td class="time">10358 ms (14751878)</td><td class="time">7873 ms (14751878)</td><td class="time">945 ms (14751878)</td><td class="time">3159 ms (14751878)</td><td class="time">1278 ms (14751878)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z0-9_]</td></tr><tr><td class="raptorPattern">[a-zA-Z0-9_]</td></tr></table></td><td class="time">3057 ms (14751878)</td><td class="time">3202 ms (14751878)</td><td class="time">4610 ms (14751878)</td><td class="time">10222 ms (14751878)</td><td class="time">7761 ms (14751878)</td><td class="time">966 ms (14751878)</td><td class="time">5490 ms (14751878)</td><td class="time">1216 ms (14751878)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]+</td></tr><tr><td class="raptorPattern">[a-zA-Z]+</td></tr></table></td><td class="time">970 ms (3495761)</td><td class="time">1538 ms (3495761)</td><td class="time">2289 ms (3495761)</td><td class="time">2905 ms (3495761)</td><td class="time">2250 ms (3495761)</td><td class="time">333 ms (3495761)</td><td class="time">2756 ms (3495761)</td><td class="time">962 ms (3495761)</td></tr>
      <tr><td class="pattern"><table><tr><td>[.\s]+</td></tr><tr><td class="raptorPattern">[.:s]+</td></tr></table></td><td class="time">925 ms (3430783)</td><td class="time">1048 ms (3430783)</td><td class="time">1922 ms (991813)</td><td class="time">2668 ms (3430783)</td><td class="time">2182 ms (3430783)</td><td class="time">385 ms (3430783)</td><td class="time">3676 ms (3430783)</td><td class="time">1378 ms (3430783)</td></tr>
      <tr><td class="pattern"><table><tr><td>([^\n]+)</td></tr><tr><td class="raptorPattern">&lt;[^\n]+&gt;</td></tr></table></td><td class="time">309 ms (314387)</td><td class="time">1179 ms (314387)</td><td class="time">1501 ms (314387)</td><td class="time">727 ms (314387)</td><td class="time">492 ms (314387)</td><td class="time">88 ms (314387)</td><td class="time">1028 ms (314387)</td><td class="time">577 ms (314387)</td></tr>
      <tr><td class="pattern"><table><tr><td>e</td></tr><tr><td class="raptorPattern">e</td></tr></table></td><td class="time">364 ms (1781425)</td><td class="time">456 ms (1781425)</td><td class="time">499 ms (1781425)</td><td class="time">1390 ms (1781425)</td><td class="time">993 ms (1781425)</td><td class="time">136 ms (1781425)</td><td class="time">1555 ms (1781425)</td><td class="time">698 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>(((((e)))))</td></tr><tr><td class="raptorPattern">&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1187 ms (1781425)</td><td class="time">1123 ms (1781425)</td><td class="time">493 ms (1781425)</td><td class="time">1883 ms (1781425)</td><td class="time">1005 ms (1781425)</td><td class="time">203 ms (1781425)</td><td class="time">17275 ms (1781425)</td><td class="time">2255 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>((((((((((e))))))))))</td></tr><tr><td class="raptorPattern">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1909 ms (1781425)</td><td class="time">1685 ms (1781425)</td><td class="time">492 ms (1781425)</td><td class="time">2137 ms (1781425)</td><td class="time">993 ms (1781425)</td><td class="time">292 ms (1781425)</td><td class="time">48426 ms (1781425)</td><td class="time">3812 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>Twain</td></tr><tr><td class="raptorPattern">Twain</td></tr></table></td><td class="time">10 ms (2388)</td><td class="time">48 ms (2388)</td><td class="time">1000 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">2605 ms (2388)</td><td class="time">605 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Twain)</td></tr><tr><td class="raptorPattern">&lt;Twain&gt;</td></tr></table></td><td class="time">14 ms (2388)</td><td class="time">49 ms (2388)</td><td class="time">990 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">5596 ms (2388)</td><td class="time">942 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?i)Twain</td></tr><tr><td class="raptorPattern">#*Twain</td></tr></table></td><td class="time">193 ms (2657)</td><td class="time">286 ms (2657)</td><td class="time">1270 ms (2657)</td><td class="time">417 ms (2657)</td><td class="time">178 ms (2657)</td><td class="time">52 ms (2657)</td><td class="time">2736 ms (2657)</td><td class="time">785 ms (2657)</td></tr>
      <tr><td class="pattern"><table><tr><td>((T|t)([wW])(a|A)i?I?([nN]))</td></tr><tr><td class="raptorPattern">&lt;&lt;T|t&gt;&lt;[wW]&gt;&lt;a|A&gt;i?I?&lt;[nN]&gt;&gt;</td></tr></table></td><td class="time">578 ms (2658)</td><td class="time">458 ms (2658)</td><td class="time">1745 ms (2658)</td><td class="time">365 ms (2658)</td><td class="time">179 ms (2658)</td><td class="time">77 ms (2658)</td><td class="time">17253 ms (2658)</td><td class="time">2356 ms (2658)</td></tr>
      <tr><td class="pattern"><table><tr><td>(T+([w]?(a{1}(i+(n*))))){1}</td></tr><tr><td class="raptorPattern">&lt;T+&lt;[w]?&lt;a{1}&lt;i+&lt;n*&gt;&gt;&gt;&gt;&gt;{1}</td></tr></table></td><td class="time">25 ms (2419)</td><td class="time">62 ms (2419)</td><td class="time">1181 ms (2419)</td><td class="time">161 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">7 ms (2419)</td><td class="time">12576 ms (2419)</td><td class="time">949 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?:T+(?:[w]?(?:a{1}(?:i+(?:n*))))){1}</td></tr><tr><td class="raptorPattern">(T+([w]?(a{1}(i+(n*))))){1}</td></tr></table></td><td class="time">21 ms (2419)</td><td class="time">62 ms (2419)</td><td class="time">1166 ms (2419)</td><td class="time">162 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">6 ms (2419)</td><td class="time">13331 ms (2419)</td><td class="time">885 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-z]shing</td></tr><tr><td class="raptorPattern">[a-z]shing</td></tr></table></td><td class="time">1476 ms (1877)</td><td class="time">2300 ms (1877)</td><td class="time">1592 ms (1877)</td><td class="time">50 ms (1877)</td><td class="time">286 ms (1877)</td><td class="time">48 ms (1877)</td><td class="time">5287 ms (1877)</td><td class="time">1350 ms (1877)</td></tr>
      <tr><td class="pattern"><table><tr><td>Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr><tr><td class="raptorPattern">Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr></table></td><td class="time">70 ms (396)</td><td class="time">76 ms (396)</td><td class="time">1561 ms (396)</td><td class="time">139 ms (396)</td><td class="time">137 ms (396)</td><td class="time">8 ms (396)</td><td class="time">7754 ms (396)</td><td class="time">1485 ms (396)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-q][^u-z]{13}x</td></tr><tr><td class="raptorPattern">[a-q][^u-z]{13}x</td></tr></table></td><td class="time">1738 ms (4929)</td><td class="time">6363 ms (4929)</td><td class="time">4466 ms (4929)</td><td class="time">157 ms (4929)</td><td class="time">587 ms (4929)</td><td class="time">5 ms (4929)</td><td class="time">9947 ms (4929)</td><td class="time">3846 ms (4929)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom|Sawyer|Huckleberry|Finn</td></tr><tr><td class="raptorPattern">Tom|Sawyer|Huckleberry|Finn</td></tr></table></td><td class="time">95 ms (3015)</td><td class="time">100 ms (3015)</td><td class="time">2742 ms (3015)</td><td class="time">161 ms (3015)</td><td class="time">141 ms (3015)</td><td class="time">84 ms (3015)</td><td class="time">11273 ms (3015)</td><td class="time">2673 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Tom|Sawyer|Huckleberry|Finn)</td></tr><tr><td class="raptorPattern">&lt;Tom|Sawyer|Huckleberry|Finn&gt;</td></tr></table></td><td class="time">101 ms (3015)</td><td class="time">103 ms (3015)</td><td class="time">2777 ms (3015)</td><td class="time">162 ms (3015)</td><td class="time">141 ms (3015)</td><td class="time">83 ms (3015)</td><td class="time">20004 ms (3015)</td><td class="time">3021 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr><tr><td class="raptorPattern">[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr></table></td><td class="time">633 ms (534)</td><td class="time">879 ms (534)</td><td class="time">2939 ms (534)</td><td class="time">689 ms (534)</td><td class="time">262 ms (534)</td><td class="time">241 ms (534)</td><td class="time">11237 ms (534)</td><td class="time">1582 ms (534)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom.{10,25}river|river.{10,25}Tom</td></tr><tr><td class="raptorPattern">Tom(river|\n){10,25}#!river|river(Tom|\n){10,25}#!Tom</td></tr></table></td><td class="time">203 ms (2)</td><td class="time">248 ms (2)</td><td class="time">1754 ms (2)</td><td class="time">251 ms (2)</td><td class="time">254 ms (2)</td><td class="time">45 ms (2)</td><td class="time">14594 ms (2)</td><td class="time">1522 ms (2)</td></tr>
      <tr><td class="pattern"><table><tr><td>ing[^a-zA-Z]</td></tr><tr><td class="raptorPattern">ing[^a-zA-Z]</td></tr></table></td><td class="time">143 ms (85956)</td><td class="time">243 ms (85956)</td><td class="time">1138 ms (85956)</td><td class="time">140 ms (85956)</td><td class="time">111 ms (85956)</td><td class="time">54 ms (85956)</td><td class="time">3199 ms (85956)</td><td class="time">652 ms (85956)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]ing[^a-zA-Z]</td></tr><tr><td class="raptorPattern">[a-zA-Z]ing[^a-zA-Z]</td></tr></table></td><td class="time">1551 ms (85823)</td><td class="time">2365 ms (85823)</td><td class="time">1794 ms (85823)</td><td class="time">142 ms (85823)</td><td class="time">330 ms (85823)</td><td class="time">57 ms (85823)</td><td class="time">6675 ms (85823)</td><td class="time">1410 ms (85823)</td></tr>
      <tr><td class="pattern"><table><tr><td>([a-zA-Z]+ing)</td></tr><tr><td class="raptorPattern">&lt;(ing|:A)+#!ing((ing|:A)*#!ing)*&gt;</td></tr></table></td><td class="time">4017 ms (95863)</td><td class="time">5382 ms (95863)</td><td class="time">2074 ms (95863)</td><td class="time">3036 ms (95863)</td><td class="time">341 ms (95863)</td><td class="time">223 ms (95863)</td><td class="time">26227 ms (95863)</td><td class="time">6501 ms (95863)</td></tr>
      </tbody></table>
    #+END_HTML

    El entorno de pruebas [[https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks][aqui]] (El entorno fue creado por [[https://sourceforge.net/u/dark100/profile/][dark100]] puede
    descargalo desde [[http://sljit.sourceforge.net/regex-test.tgz][aqui]]). Solo descargalo, escribe =make= y ejecuta =runtest=.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y acorde a
  ello se utiliza la licencia GNU GPL Version 3. Cualquier obra que incluya o
  derive codigo de esta libreria, debera cumplir con los terminos de esta
  licencia.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
