#+TITLE:    Recursive Regexp Raptor (regexp3)
#+AUTHOR:   nasciiboy
#+LANGUAGE: es
#+STARTUP:  showall

lang: [[file:readme.org][en]]

regexp4: [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][aqui]]

raptor-book (borrador) : [[https://github.com/nasciiboy/raptor-book/][aqui]]

* Caracteristicas

  - Manejo sencillo,

  - Sin verificacion de errores.

  - Solo expresiones regulares

  - El codigo mas compacto y claro que alla precenciado nunca antes
    alguna libreria regexp humana.

  - Cero dependencias. Ni la libreria estandar de C esta precente *C PURO*.

  - Manejo no explicito de memoria dinamica. Ningun =malloc=, =calloc=, =free=,
    ...

  - Conteo de coincidencias

  - Capturas

  - Reemplazo de capturas

  - Colocacion de capturas especificas dentro de un arreglo

  - Negacion de expreciones (experimental)

  - Referencia dentro de la exprecion a capturas previas

  - Soporte UTF8

* Introduccion

  *Recurseve Regexp Raptor* es una libreria de busqueda, captura y reemplazo de
  expresiones regulares escrita en lenguaje C desce cero, intentando lograr lo
  siguiente:

  - Contar con la mayoria de caracteristicas presentes en cualquier otra
    libreria regexp.

  - Codigo elegante: sencillo, claro y dotado de gracia.

  - Evitar la peticion explicita de memoria dinamica.

  - Evitar el uso de ninguna libreria externa, incluida la libreria estandar.

  - Ser util como material de aprendizaje.


  Existen dos desarrollos paralelos de esta libreria el primero (el presente) se
  centra en la simplicidad y el codigo, el segundo aun en fase beta ([[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4]])
  intenta alcanzar la maxima velocidad posible implemetando una "tabla de
  instrucciones". En ambos casos el algoritmo parte de cero, y solo se hace uso
  de C tal cual, enjoy!

** Motivacion

   C no dispone de una libreria estandar de expresiones regulares, si bien
   existen varias implementaciones, como pcre, la libreria regexp.h del proyecto
   GNU, regexp del sistema operativo Plan 9, y algunas otras mas, el autor de
   este trabajo (que igual y es un poco retard) encontro en todas codigo
   rebuscado y mistico repartido en varios ficheros, llenos de macros, guiones
   bajos y variables cripticas. Incapas de entender nada y tras un retiro a la
   isla de la meditacion onanista el autor se propuso hacer su propia libreria
   con casinos y colegialas japonesas.

** Desarrollo y pruebas

   Se ha utilizado GNU Emacs (el unico y verdadero sistema operativo), los
   compiladores gcc (6.3.1) y clang (LLVM) 3.8.1, konsole y fish, corriendo en
   Freidora 25.

   existen dos pruebas para la libreria, la primera es una bateria de pruebas
   ascii en el fichero =ascii_test.c=.

   para probar la vercion ascii de la libreria

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_ascii.c
   #+END_SRC

   para la vercion UTF8

   #+BEGIN_SRC sh
     gcc ascii_test.c regexp3_utf8.c
   #+END_SRC

   la segunda bateria de pruebas es exclusiva de =regexp3_utf8.c=

   #+BEGIN_SRC sh
     gcc utf8_test.c regexp3_utf8.c
   #+END_SRC

   en cualquiera de los casos ejecute con

   #+BEGIN_SRC sh
     ./a.out
   #+END_SRC

* Uso

  Para incluir Recursive Regexp Raptor en su codigo necesita colocar los
  ficheros =regexp3.h=, =charUtils.h= y de pendiendo del caso de uso
  =regexp3_ascii.c= o =regexp3_utf8.c= dentro de la carpeta de su
  proyecto. Debe incluir el encabezado

  #+BEGIN_SRC c
    #include "regexp3.h"
  #+END_SRC

  y por ultimo compilar bien con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_ascii.c
  #+END_SRC

  o con

  #+BEGIN_SRC sh
    gcc miProyecto.c regexp3_utf8.c
  #+END_SRC

  obviamente, compilar con optimizacion proporciona una disminucion drastica del
  tiempo de ejecucion, intente con =-O3=

** funcion =regexp3()=

   Esta es la unica funcion de busqueda, aqui su prototipo:

   #+BEGIN_SRC c
     int regexp3( const char *txt, const char *re );
   #+END_SRC

   - txt  :: apuntador a cadena sobre la que efectuar la busqueda, debe
             finalizar con el signo de terminacion '\0'.

   - re   :: apuntador a cadena que contiene la expresion regular de busqueda,
             debe finalizar con el signo de terminacion '\0'.


   La funcion regresa el numero de coincidencias =0= (ninguna) o =n=
   coincidencias.

   La sintaxis estandar para expresiones regulares utiliza el caracter '=\=',
   lamentablemente este signo entra en "conflicto" con la sintaxis de C, por
   esto e intentando mantener el codigo lo mas sencillo, se ha optado por una
   sintaxis alterna detallada a continuacion

** Sintaxis

   - busqueda de texto en cualquier ubicacion:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Raptor" );
     #+END_SRC

   - multiples opciones de busqueda "exp1|exp2"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Dinosaur|T Rex|Raptor|Triceratops" );
     #+END_SRC

   - coincidencia con cualquier caracter '.'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R.ptor" );
     #+END_SRC

   - coincidencia cero o una ves '?'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra?ptor" );
     #+END_SRC

   - coincidencia una o mas veces '+'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra+ptor" );
     #+END_SRC

   - coincidencia cero o mas veces '*'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra*ptor" );
     #+END_SRC

   - rango de coincidencias "{n1,n2}"

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{0,100}ptor" );
     #+END_SRC

   - numero de coincidencias especifico '{n1}'

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "Ra{1}ptor" );
     #+END_SRC

   - numero minimo de coincidencias '{n1,}'

     #+BEGIN_SRC c
       regexp3( "Raaaptor Test", "Ra{1,}ptor" );
     #+END_SRC

   - Conjuntos.

     - Conjunto de caracteres "[abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[uoiea]ptor" );
       #+END_SRC

     - Rango dentro de un conjunto de caracteres "[a-b]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[a-z]ptor" );
       #+END_SRC

     - Metacaracter dentro de un conjunto de caracteres "[:meta]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[:w]ptor" );
       #+END_SRC

     - inversion de conjunto de caracteres  "[^abc]"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "R[^uoie]ptor" );
       #+END_SRC

   - caracteres con codificacion utf8

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R△ptor" );
     #+END_SRC

     tambien

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R[△]ptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una letra ":a"

     #+BEGIN_SRC c
       regexp3( "RAptor Test", "R:aptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea una letra ":A"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Aptor" );
     #+END_SRC

   - coincidencia con un caracter que sea una numero ":d"

     #+BEGIN_SRC c
       regexp3( "R4ptor Test", "R:dptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un numero ":D"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Dptor" );
     #+END_SRC

   - coincidencia con un caracter alfanumerico ":w"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:wptor" );
     #+END_SRC

   - coincidencia con un caracter no alfanumerico ":W"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:Wptor" );
     #+END_SRC

   - coincidencia con un caracter que sea un espacio ":s"

     #+BEGIN_SRC c
       regexp3( "R ptor Test", "R:sptor" );
     #+END_SRC

   - coincidencia con un caracter que no sea un espacio ":S"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "R:Sptor" );
     #+END_SRC

   - coincidencia con un caracter utf8 ":&"

     #+BEGIN_SRC c
       regexp3( "R△ptor Test", "R:&ptor" );
     #+END_SRC

   - escape de caracteres con significado especial ":caracter"

     los caracteres '|', '(', ')', '<', '>', '[', ']', '?', '+', '*', '{', '}',
     '-', '#' y '@' indican como debe procesarse la exprecion regular, colocar
     alguno de estos caracteres tal cual, sin tener en cuenta una correcta
     sintaxis dentro de la exprecion, puede generar bucles infinitos al igual
     que errores por violacion de segmento.

     #+BEGIN_SRC c
       regexp3( ":#()|<>", ":::#:(:):|:<:>" );
     #+END_SRC

     los caracteres /especiales/ (exepto el metacarater =:=) pierden su
     significado detro de un conjunto

     #+BEGIN_SRC c
       regexp3( "()<>[]|{}*#@?+", "[()<>:[:]|{}*?+#@]" );
     #+END_SRC

   - agrupacion "(exp)"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "(Raptor)" );
     #+END_SRC

   - agrupacion con captura "<exp>"

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "<Raptor>" );
     #+END_SRC

   - backreferences "@id"

     las referencias necesitan que previamente se halla capturado una exprecion
     mediante "<exp>", luego se coloca el numero de aparicion de la captura
     precidido por '@'

     #+BEGIN_SRC c
       regexp3( "ae_ea", "<a><e>_@2@1" )
     #+END_SRC

   - modificadores de comportamiento

     Existen dos tipos de modificadores. El primero afecta de forma global el
     comportamiento de la exprecion, el segundo afecta secciones en
     especifico. En ambos caso los la sintaxis es la misma, el signo '#',
     seguido por los modificadores,

     los modificadores de alcance global se coloca al inicio, de toda la
     exprecion y son los siguientes

     - busqueda solo al inicio '#^exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^Raptor" );
       #+END_SRC

     - busqueda solo al final '#$exp'

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#$Test" );
       #+END_SRC

     - busqueda al inicio y final "#^$exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#^$Raptor Test" );
       #+END_SRC

     - detener con la primer coincidencia "#?exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#?Raptor Test" );
       #+END_SRC

     - buscar por la cadena caracter a caracter "#~"

       de forma predeterminada cuando una exprecion coincide con una region del
       texto de busqueda, la busqueda prosigue a partir del final de dicha
       coincidencia, para ignorar este comportamiento, haciendo que la busqueda
       siempre sea caracter a caracter se utiliza este modificador

       #+BEGIN_SRC c
         regexp3( "aaaaa", "#~a*" );
       #+END_SRC

       en este ejemplo, sin el modificador el resultado seria una coincidencia,
       sin embargo con este modificador la busqueda continua inmediatamente
       despues del siguente caracter regresando cinco coincidencias.

     - ignorar entre minusculas y mayusculas "#*exp"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "#*RaPtOr TeSt" );
       #+END_SRC


     todos los modificadores anteriores son compatibles entre si es decir podria
     buscar

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#^$*?~RaPtOr TeSt" );
     #+END_SRC

     sin embargo los  modificadores  '~' y '?' pierden sentido debido a la
     presencia de '^' y/o '$'.

     una exprecion del tipo:

     #+BEGIN_SRC c
       regexp3( "Raptor Test", "#$RaPtOr|#$TeSt" );
     #+END_SRC

     es erronea, el modificador despues del '|' se aplicaria la seccion entre
     '|' y '#', es decir cero, con un retorno de erroneo

     los modificadores locales se colocan despues del indicador de repeticion
     (de existir) y afectan la misma region que afectan los indicadores de
     repeticion, es decir caracteres, conjuntos o agrupaciones.

     - ignorar entre minusculas y mayusculas "exp#*"

       #+BEGIN_SRC c
         regexp3( "Raptor Test", "(RaPtOr)#* TeS#*t" );
       #+END_SRC

     - no ignorar entre minusculas y mayusculas "exp#/"

       #+BEGIN_SRC c
         regexp3( "RaPtOr TeSt", "#*(RaPtOr)#/ TES#/T" );
       #+END_SRC

     - *negacion de exprecion* "exp#!"

       esta poco convencional exprecion permite el equivalente en otras
       librerias a expreciones tipo

       #+BEGIN_SRC c
         xx.*yy
       #+END_SRC

       es decir "xx" seguida por cualquier cosa que no sea "yy", seguida por "yy".
       En esta sintaxis seria

       #+BEGIN_SRC c
         regexp3( "xx123456789yy", "xx(yy)*#!yy" );
       #+END_SRC

** Capturas

   Las capturas se indexan segun el orden de aparicion dentro de la expresion
   por ejemplo:

   #+BEGIN_EXAMPLE
     <   <   >  | <   <   >   >   >
     = 1 ==========================
         = 2==    = 2 =========
                      = 3 =
   #+END_EXAMPLE

   Si la exprecion coincide mas de una ocacion dentro del texto de busqueda el
   indice, se incrementa segun su aparicion es decir:

   #+BEGIN_EXAMPLE
     <   <   >  | <   >   >   <   <   >  | <   >   >   <   <   >  | <   >   >
     = 1 ==================   = 3 ==================   = 5 ==================
         = 2==    = 2==           = 4==    = 4==           = 6==    = 6==
     coincidencia uno         coincidencia dos         coincidencia tres
   #+END_EXAMPLE

   la funcion =cpytCatch= hace una copia de una la captura dentro de un arreglo
   de caracteres, aqui su prototipo:

   #+BEGIN_SRC c
     char * cpyCatch( char * str, const int index )
   #+END_SRC

   - str   :: puntero lo suficientemete grande para contener la captura.

   - index :: indice de la agrupacion (de =1= a =n=).


   la funcion regeresa un apuntador a la captura terminada en '\0'. Un indice
   incorrecto regresara un apuntador que inicia en '\0'.

   para optener el numero capturadas dentro de una busqueda, utlice
   =totCatch=:

   #+BEGIN_SRC c
     int totCatch();
   #+END_SRC

   que regresa un valor de =0= a =n=.

   Podria utilzar esta y la anterior funcion para imprimir las capturadas con
   una funcion como esta:

   #+BEGIN_SRC c
     void printCatch(){
       char str[128];
       int i = 0, max = totCatch();

       while( ++i <= max )
         printf( "[%d] >%s<\n", i, cpyCatch( str, i ) );
     }
   #+END_SRC

*** =gpsCatch()= y =lenCatch()=

    las funciones =gpsCatch()= y =lenCatch()= realizan la misma labor que
    =cpyCatch= con la variante de no utilizar un arreglo, en su lugar la primera
    regresa un puntero a la posicion inicial de la captura dentro del texto de
    busqueda y la segunda regresa la longitud de dicha captura.

    #+BEGIN_SRC c
      int          lenCatch( const int index );
      const char * gpsCatch( const int index );
    #+END_SRC

    el ejemplo anterior con estas fuciones, seria:

    #+BEGIN_SRC c
      void printCatch(){
        int i = 0, max = totCatch();

        while( ++i <= max )
          printf( "[%d] >%.*s<\n", i, lenCatch( i ), gpsCatch( i ) );
      }
    #+END_SRC

*** Colocar capturas dentro de una cadena

    #+BEGIN_SRC c
      char * putCatch( char * newStr, const char * putStr );
    #+END_SRC

    el argumento =putStr= contiene el texto con el cual formar la nueva cadena
    asi como indicadores de cuales capturas colocar. Para indicar la insercion
    de una captura coque el signo '#' seguido del indice de captura. por ejemplo
    el argumento =putStr= podria ser

    #+BEGIN_SRC c
      char *putStr = "captura 1 >>#1<< captura 2 >>#2<< captura 747 >>#747<<";
    #+END_SRC

    =newStr= es un arreglo de caracteres lo suficientemente grande como para
    contener la cadena + las capturas. la funcion regresa un apuntador a la
    posicion inicial de este arreglo, que finaliza con el signo de terminacion
    '\0'.

    para colocar el caracter '#' dentro de la cadena escape '#' con un '#'
    adicional, es decir:

    #+BEGIN_EXAMPLE
      "## comentario"  -> "# comentario"
    #+END_EXAMPLE

*** Reemplazar una captura

    El reemplazo opera sobre un arreglo de caracteres en el cual se coloca el
    texto de busqueda modificando una captura especifica por una cadena de
    texto, la funcion encargada de esta labor es =rplCatch=, su prototipo es:

    #+BEGIN_SRC c
      char * rplCatch( char * newStr, const char * rplStr, const int id );
    #+END_SRC

    - newStr :: arreglo de caracteres de dimension dende se colocara el texto
                original sobre el que se efectua y el texto de reemplazo de las
                capturas.

    - rplStr :: texto de reemplazo para captura.

    - id     :: *identificador* de captura segun el orden de aparicion dentro de
                la exprecion regular. Pasar un indice incorrecto, coloca una
                copia sin modificacion de la cadena de busqueda sobre el arreglo
                =newStr=.


    en este caso el uso del argumento =id= a diferencia de la funcion =getCatch=
    no se refiere a una "captura" en especifico, es decir no importa la cantidad
    de ocaciones que se ha capturado una exprecion, el identificador indica la
    *posicion* dentro de la exprecion en si, es decir:

    #+BEGIN_EXAMPLE
         <   <   >  | <   <   >   >   >
      id = 1 ==========================
      id     = 2==    = 2 =========
      id                  = 3 =
      posicion de la captura dentro de la exprecion
    #+END_EXAMPLE

    la modificacion afecta de este modo

    #+BEGIN_EXAMPLE
      <   <   >  | <   >   >       <   <   >  | <   >   >      <   <   >  | <   >   >
      = 1 ==================       = 1 ==================      = 1 ==================
          = 2==    = 2==               = 2==    = 2==              = 2==    = 2==
      captura uno                  "..." dos                   "..." tres
    #+END_EXAMPLE

** Metacaracteres de busqueda

   - =:d= :: dígito del 0 al 9.
   - =:D= :: cualquier carácter que no sea un dígito del 0 al 9.
   - =:a= :: cualquier caracter que sea una letra (a-z,A-Z)
   - =:A= :: cualquier caracter que no sea una letra
   - =:w= :: cualquier carácter alfanumérico.
   - =:W= :: cualquier carácter no alfanumérico.
   - =:s= :: cualquier caracter de espacio en blanco.
   - =:S= :: cualquier carácter que no sea un espacio en blanco.
   - =:&= :: caracter no ascii (solo en version UTF8).

   - =:|= :: barra vertical
   - =:^= :: acento circunflejo
   - =:$= :: signo dolar
   - =:(= :: parentesis izquierdo
   - =:)= :: parentesis derecho
   - =:<= :: mayor que
   - =:>= :: menor que
   - =:[= :: corchete izquierdo
   - =:]= :: corchete derecho
   - =:.= :: punto
   - =:?= :: interrogacion
   - =:+= :: mas
   - =:-= :: menos
   - =:*= :: asterisco
   - =:{= :: llave izquierda
   - =:}= :: llave derecha
   - =:#= :: modificador
   - =::= :: dos puntos


   adicionalmente utilice la sintaxis propia de c para colocar caracteres como
   nueva linea, tabulador, campana,..., etc. De igual forma puede utilizar la
   sintaxis c para "colocar" caracteres en notacion octal, hexadecimal o
   unicode.

** algunos ejemplos de uso

   El fichero =ascii_test.c= contiene una amplia variedad de pruebas que son
   utiles como ejemplos de uso, entre estos se encuentran los siguentes:

   #+BEGIN_SRC c
     regexp3( "07-07-1777", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>" );
   #+END_SRC

   captura una cadena con formato de fecha, de forma separada dia, separador,
   mes y año. El separador tiene que coincider las dos ocaciones que aparece

   #+BEGIN_SRC c
      regexp3( "https://en.wikipedia.org/wiki/Regular_expression", "(https?|ftp):://<[^:s/:<:>]+></[^:s:.:<:>,/]+>*<.>*" );
   #+END_SRC

   capturar algo parecido a un enlace web

   #+BEGIN_SRC c
     regexp3( "<mail>nasciiboy@gmail.com</mail>", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><:.[A-Za-z0-9]{2}>*" );
   #+END_SRC

   capturar por secciones (usuario,sitio,dominio) algo parecido a un correo.

   #+BEGIN_SRC c
      regexp3( "xx0123yy", "<xx><yy>*#!<yy>" );
   #+END_SRC

   capturar una cadena que contenga "xx", luego captura cualquier cosa que no
   sea "yy" y finalmente captura nuevamente "yy"

* Hacking
** algoritmo
*** Diagrama de flujo

    Esta diagrama es una aproximacion del funcionimento del motor, los nombres no
    se corresponden con los nombres del codigo, para una explicacion completa
    revisar el [[https://github.com/nasciiboy/raptor-book/][libro]]

    #+BEGIN_EXAMPLE
          ┌──────┐
          │inicio│
          └──────┘
              │◀───────────────────────────────────┐
              ▼                                    │
      ┌────────────────┐                           │
      │bucle por cadena│                           │
      └────────────────┘                           │
              │                                    │
              ▼                                    │
       ┌─────────────┐  no   ┌─────────────┐       │
      <│fin de cadena│>────▶<│buscar regexp│>──────┘
       └─────────────┘       └─────────────┘  no coincide
              │ si                  │ coincide
              ▼                     ▼
      ┌────────────────┐    ┌────────────────┐
      │informar: no    │    │informar:       │
      │hay coincidencia│    │hay coincidencia│
      └────────────────┘    └────────────────┘
              │                     │
              │◀────────────────────┘
              ▼
            ┌───┐
            │fin│
            └───┘
    #+END_EXAMPLE

    En esta version de @c(buscar regexp) todos los constructores se optienen por
    una sola funcion:

    #+BEGIN_EXAMPLE
                                                                  ┌───────────────────────────────┐
      ┏━━━━━━━━━━━━━┓                                             ▼                               │
      ┃buscar regexp┃                                   ┌───────────────────┐                     │
      ┗━━━━━━━━━━━━━┛                                   │Optener constructor│                     │
                                                        └───────────────────┘                     │
                                                                  │                               │
                                                                  ▼                               │
                                                          ┌───────────────┐  no  ┌─────────────┐  │
                                                         <│hay constructor│>────▶│terminar: la │  │
                                                          └───────────────┘      │ruta coincide│  │
                                                                  │ si           └─────────────┘  │
                                    ┌──────────┬────────┬─────────┼───────────┬──────────┐        │
                                    ▼          ▼        ▼         ▼           ▼          ▼        │
                              ┌───────────┐┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐  │
                              │alternacion││conjunto││punto││metacaracter││caracter││agrupacion│  │
                              └───────────┘└────────┘└─────┘└────────────┘└────────┘└──────────┘  │
                                    │          │        │         │           │          │        │
                                    ▼          └────────┴─────────┼───────────┘          └────────┤
                             ┌──────────────────┐                 │                               │
                  ┌──────────│ guardar posicion │                 ▼               no              │
                  │          └──────────────────┘       ┌──────────────────┐   coincide           │
                  │          ┌──────────────────┐      <│buscar constructor│>─────────┐           │
                  ▼◀─────────│restaurar posicion│◀──┐   └──────────────────┘          │           │
           ┌───────────────┐ └──────────────────┘   │             │ coincide          │           │
           │recorrer rutas │                        │             ▼                   ▼           │
           └───────────────┘                        │    ┌──────────────────┐ ┌────────────────┐  │
                  │                                 │    │avanzar por cadena│ │terminar, ruta  │  │
                  ▼                                 │    └──────────────────┘ │sin coincidencia│  │
              ┌────────┐   si     ┌─────────────┐   │             │           └────────────────┘  │
             <│hay ruta│>───────▶<│buscar regexp│>──┘             └───────────────────────────────┘
              └────────┘          └─────────────┘ no coincide
                  │ no           coincide │
                  ▼                       ▼
      ┌─────────────────────────┐ ┌─────────────┐
      │terminar sin coincidencia│ │terminar, la │
      └─────────────────────────┘ │ruta coincide│
                                  └─────────────┘
    #+END_EXAMPLE

    =buscar regexp=: diseño actual

    #+BEGIN_EXAMPLE
                    ┌──────────────────┐
                    │ guardar posicion │                                 ┏━━━━━━━━━━━━━┓
                    └──────────────────┘                                 ┃buscar regexp┃
               ┌────────────▶│                                           ┗━━━━━━━━━━━━━┛
               │             ▼
               │      ┌───────────────┐
               │      │recorrer rutas │
               │      └───────────────┘
               │             │                         ┌─────────────────────────────────┐
               │             ▼                         ▼                                 │
               │         ┌────────┐   si     ┌───────────────────┐                       │
               │        <│hay ruta│>────────▶│obtener constructor│                       │
               │         └────────┘          └───────────────────┘                       │
               │             │ no                      │                                 │
               │             ▼                         ▼                                 │
               │ ┌─────────────────────────┐   ┌───────────────┐  no  ┌─────────────┐    │
               │ │terminar sin coincidencia│  <│hay constructor│>────▶│terminar: la │    │
               │ └─────────────────────────┘   └───────────────┘      │ruta coincide│    │
               │                                       │ si           └─────────────┘    │
               │                    ┌────────┬─────────┼───────────┬──────────┐          │
               │                    ▼        ▼         ▼           ▼          ▼          │
      ┌──────────────────┐      ┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐    │
      │restaurar posicion│      │conjunto││punto││metacaracter││caracter││agrupacion│    │
      └──────────────────┘      └────────┘└─────┘└────────────┘└────────┘└──────────┘    │
               ▲                    │        │         │           │          │          │
               │                    └────────┴─────────┼───────────┘          │          │
               │                                       ▼                      ▼          │
       ┌────────────────┐    no coincide     ┌──────────────────┐      ┌─────────────┐   │
       │terminar: ruta  │◀────────┬─────────<│buscar constructor│>  ┌─<│buscar regexp│>  │
       │sin coincidencia│         │          └──────────────────┘   │  └─────────────┘   │
       └────────────────┘         │                    │ coincide   │         │          │
                                  └──────────────────┈┈│┈┈──────────┘         │ coincide │
                                                       ▼                      │          │
                                              ┌──────────────────┐            └──────────┤
                                              │avanzar por cadena│                       │
                                              └──────────────────┘                       │
                                                       │                                 │
                                                       └─────────────────────────────────┘
    #+END_EXAMPLE

* Benchmarks

  Se eligieron los sigientes motores como punto de comparacion:

  - [[http://www.pcre.org/][PCRE2 10.10]]
  - [[https://github.com/laurikari/tre/][tre 0.8.0]]
  - [[http://www.geocities.jp/kosako3/oniguruma/][Oniguruma 5.9.6]]
  - [[https://github.com/google/re2][re2 by Google]]
  - [[http://sljit.sourceforge.net/pcre.html][PCRE2 10.10 with sljit JIT compiler support]]


  vs el Raptor ([[https://github.com/nasciiboy/RecursiveRegexpRaptor][regexp3_ascii.c]] & [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4_ascii.c]])

** Results
*** x86-64 bit Intel Cerelon 847 1.1GHz (GCC 6.3.1, GNU/Linux)

    #+BEGIN_HTML
      <table class="results" border="1" width="100%">
      <tbody><tr><th>Regular expression</th><th>PCRE</th><th>PCRE<br>-DFA</th><th>TRE</th><th>Onig-<br>uruma</th><th>RE2</th><th>PCRE<br>-JIT</th><th class="raptor3">regexp3</th><th class="raptor4">regexp4</th></tr>
      <tr><td class="pattern"><table><tr><td>.|\n</td></tr><tr><td class="raptorPattern">.</td></tr></table></td><td class="time">4526 ms (20045118)</td><td class="time">5305 ms (20045118)</td><td class="time">6513 ms (20045118)</td><td class="time">13005 ms (20045118)</td><td class="time">10611 ms (20045118)</td><td class="time">1090 ms (20045118)</td><td class="time">1409 ms (20045118)</td><td class="time">750 ms (20045118)</td></tr>
      <tr><td class="pattern"><table><tr><td>\d</td></tr><tr><td class="raptorPattern">:d</td></tr></table></td><td class="time">66 ms (27084)</td><td class="time">67 ms (27084)</td><td class="time">1035 ms (27084)</td><td class="time">150 ms (27084)</td><td class="time">150 ms (27084)</td><td class="time">57 ms (27084)</td><td class="time">1351 ms (27084)</td><td class="time">616 ms (27084)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S</td></tr><tr><td class="raptorPattern">:S</td></tr></table></td><td class="time">3021 ms (15451664)</td><td class="time">3138 ms (15451664)</td><td class="time">4543 ms (15451664)</td><td class="time">10150 ms (15451664)</td><td class="time">8326 ms (15451664)</td><td class="time">901 ms (15451664)</td><td class="time">1460 ms (15451664)</td><td class="time">955 ms (15451664)</td></tr>
      <tr><td class="pattern"><table><tr><td>\S+</td></tr><tr><td class="raptorPattern">:S+</td></tr></table></td><td class="time">903 ms (3414592)</td><td class="time">1589 ms (3414592)</td><td class="time">2458 ms (3414592)</td><td class="time">2862 ms (3414592)</td><td class="time">2177 ms (3414592)</td><td class="time">323 ms (3414592)</td><td class="time">1062 ms (3414592)</td><td class="time">715 ms (3414592)</td></tr>
      <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptorPattern">:w</td></tr></table></td><td class="time">2908 ms (14751878)</td><td class="time">3034 ms (14751878)</td><td class="time">4614 ms (14751878)</td><td class="time">10346 ms (14751878)</td><td class="time">7866 ms (14751878)</td><td class="time">947 ms (14751878)</td><td class="time">1456 ms (14750958)</td><td class="time">946 ms (14750958)</td></tr>
      <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptorPattern">[:w_]</td></tr></table></td><td class="time">2908 ms (14751878)</td><td class="time">3040 ms (14751878)</td><td class="time">4585 ms (14751878)</td><td class="time">10341 ms (14751878)</td><td class="time">7922 ms (14751878)</td><td class="time">948 ms (14751878)</td><td class="time">3129 ms (14751878)</td><td class="time">1298 ms (14751878)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z0-9_]</td></tr><tr><td class="raptorPattern">[a-zA-Z0-9_]</td></tr></table></td><td class="time">3042 ms (14751878)</td><td class="time">3205 ms (14751878)</td><td class="time">4632 ms (14751878)</td><td class="time">10211 ms (14751878)</td><td class="time">7977 ms (14751878)</td><td class="time">966 ms (14751878)</td><td class="time">5619 ms (14751878)</td><td class="time">1205 ms (14751878)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]+</td></tr><tr><td class="raptorPattern">[a-zA-Z]+</td></tr></table></td><td class="time">968 ms (3495761)</td><td class="time">1538 ms (3495761)</td><td class="time">2290 ms (3495761)</td><td class="time">2905 ms (3495761)</td><td class="time">2326 ms (3495761)</td><td class="time">332 ms (3495761)</td><td class="time">2722 ms (3495761)</td><td class="time">898 ms (3495761)</td></tr>
      <tr><td class="pattern"><table><tr><td>[.\s]+</td></tr><tr><td class="raptorPattern">[.:s]+</td></tr></table></td><td class="time">910 ms (3430783)</td><td class="time">1044 ms (3430783)</td><td class="time">1901 ms (991813)</td><td class="time">2675 ms (3430783)</td><td class="time">2217 ms (3430783)</td><td class="time">388 ms (3430783)</td><td class="time">3610 ms (3430783)</td><td class="time">1393 ms (3430783)</td></tr>
      <tr><td class="pattern"><table><tr><td>([^\n]+)</td></tr><tr><td class="raptorPattern">&lt;[^\n]+&gt;</td></tr></table></td><td class="time">312 ms (314387)</td><td class="time">1177 ms (314387)</td><td class="time">1511 ms (314387)</td><td class="time">713 ms (314387)</td><td class="time">477 ms (314387)</td><td class="time">87 ms (314387)</td><td class="time">989 ms (314387)</td><td class="time">596 ms (314387)</td></tr>
      <tr><td class="pattern"><table><tr><td>e</td></tr><tr><td class="raptorPattern">e</td></tr></table></td><td class="time">360 ms (1781425)</td><td class="time">452 ms (1781425)</td><td class="time">496 ms (1781425)</td><td class="time">1377 ms (1781425)</td><td class="time">1004 ms (1781425)</td><td class="time">140 ms (1781425)</td><td class="time">1496 ms (1781425)</td><td class="time">702 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>(((((e)))))</td></tr><tr><td class="raptorPattern">&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1208 ms (1781425)</td><td class="time">1167 ms (1781425)</td><td class="time">486 ms (1781425)</td><td class="time">1870 ms (1781425)</td><td class="time">1005 ms (1781425)</td><td class="time">211 ms (1781425)</td><td class="time">16923 ms (1781425)</td><td class="time">3483 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>((((((((((e))))))))))</td></tr><tr><td class="raptorPattern">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1892 ms (1781425)</td><td class="time">1697 ms (1781425)</td><td class="time">487 ms (1781425)</td><td class="time">2136 ms (1781425)</td><td class="time">1009 ms (1781425)</td><td class="time">288 ms (1781425)</td><td class="time">48457 ms (1781425)</td><td class="time">5143 ms (1781425)</td></tr>
      <tr><td class="pattern"><table><tr><td>Twain</td></tr><tr><td class="raptorPattern">Twain</td></tr></table></td><td class="time">10 ms (2388)</td><td class="time">48 ms (2388)</td><td class="time">1010 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">2471 ms (2388)</td><td class="time">613 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Twain)</td></tr><tr><td class="raptorPattern">&lt;Twain&gt;</td></tr></table></td><td class="time">14 ms (2388)</td><td class="time">49 ms (2388)</td><td class="time">992 ms (2388)</td><td class="time">54 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">5425 ms (2388)</td><td class="time">998 ms (2388)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?i)Twain</td></tr><tr><td class="raptorPattern">#*Twain</td></tr></table></td><td class="time">192 ms (2657)</td><td class="time">286 ms (2657)</td><td class="time">1255 ms (2657)</td><td class="time">418 ms (2657)</td><td class="time">176 ms (2657)</td><td class="time">52 ms (2657)</td><td class="time">2591 ms (2657)</td><td class="time">779 ms (2657)</td></tr>
      <tr><td class="pattern"><table><tr><td>((T|t)([wW])(a|A)i?I?([nN]))</td></tr><tr><td class="raptorPattern">&lt;&lt;T|t&gt;&lt;[wW]&gt;&lt;a|A&gt;i?I?&lt;[nN]&gt;&gt;</td></tr></table></td><td class="time">579 ms (2658)</td><td class="time">457 ms (2658)</td><td class="time">1753 ms (2658)</td><td class="time">364 ms (2658)</td><td class="time">175 ms (2658)</td><td class="time">76 ms (2658)</td><td class="time">16992 ms (2658)</td><td class="time">2492 ms (2658)</td></tr>
      <tr><td class="pattern"><table><tr><td>(T+([w]?(a{1}(i+(n*))))){1}</td></tr><tr><td class="raptorPattern">&lt;T+&lt;[w]?&lt;a{1}&lt;i+&lt;n*&gt;&gt;&gt;&gt;&gt;{1}</td></tr></table></td><td class="time">25 ms (2419)</td><td class="time">62 ms (2419)</td><td class="time">1176 ms (2419)</td><td class="time">161 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">7 ms (2419)</td><td class="time">12414 ms (2419)</td><td class="time">1023 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>(?:T+(?:[w]?(?:a{1}(?:i+(?:n*))))){1}</td></tr><tr><td class="raptorPattern">(T+([w]?(a{1}(i+(n*))))){1}</td></tr></table></td><td class="time">21 ms (2419)</td><td class="time">62 ms (2419)</td><td class="time">1159 ms (2419)</td><td class="time">162 ms (2419)</td><td class="time">8 ms (2419)</td><td class="time">7 ms (2419)</td><td class="time">12761 ms (2419)</td><td class="time">941 ms (2419)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-z]shing</td></tr><tr><td class="raptorPattern">[a-z]shing</td></tr></table></td><td class="time">1455 ms (1877)</td><td class="time">2303 ms (1877)</td><td class="time">1599 ms (1877)</td><td class="time">51 ms (1877)</td><td class="time">284 ms (1877)</td><td class="time">48 ms (1877)</td><td class="time">5209 ms (1877)</td><td class="time">1318 ms (1877)</td></tr>
      <tr><td class="pattern"><table><tr><td>Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr><tr><td class="raptorPattern">Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr></table></td><td class="time">71 ms (396)</td><td class="time">75 ms (396)</td><td class="time">1560 ms (396)</td><td class="time">139 ms (396)</td><td class="time">137 ms (396)</td><td class="time">8 ms (396)</td><td class="time">6499 ms (396)</td><td class="time">1555 ms (396)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-q][^u-z]{13}x</td></tr><tr><td class="raptorPattern">[a-q][^u-z]{13}x</td></tr></table></td><td class="time">1735 ms (4929)</td><td class="time">6367 ms (4929)</td><td class="time">4402 ms (4929)</td><td class="time">157 ms (4929)</td><td class="time">583 ms (4929)</td><td class="time">5 ms (4929)</td><td class="time">9890 ms (4929)</td><td class="time">3607 ms (4929)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom|Sawyer|Huckleberry|Finn</td></tr><tr><td class="raptorPattern">Tom|Sawyer|Huckleberry|Finn</td></tr></table></td><td class="time">96 ms (3015)</td><td class="time">101 ms (3015)</td><td class="time">2771 ms (3015)</td><td class="time">162 ms (3015)</td><td class="time">142 ms (3015)</td><td class="time">84 ms (3015)</td><td class="time">10794 ms (3015)</td><td class="time">2809 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>(Tom|Sawyer|Huckleberry|Finn)</td></tr><tr><td class="raptorPattern">&lt;Tom|Sawyer|Huckleberry|Finn&gt;</td></tr></table></td><td class="time">103 ms (3015)</td><td class="time">104 ms (3015)</td><td class="time">2773 ms (3015)</td><td class="time">165 ms (3015)</td><td class="time">142 ms (3015)</td><td class="time">84 ms (3015)</td><td class="time">19548 ms (3015)</td><td class="time">3164 ms (3015)</td></tr>
      <tr><td class="pattern"><table><tr><td>[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr><tr><td class="raptorPattern">[hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo][hHeELlOo]</td></tr></table></td><td class="time">630 ms (534)</td><td class="time">879 ms (534)</td><td class="time">2924 ms (534)</td><td class="time">691 ms (534)</td><td class="time">258 ms (534)</td><td class="time">241 ms (534)</td><td class="time">11311 ms (534)</td><td class="time">1588 ms (534)</td></tr>
      <tr><td class="pattern"><table><tr><td>Tom.{10,25}river|river.{10,25}Tom</td></tr><tr><td class="raptorPattern">Tom(river|\n){10,25}#!river|river(Tom|\n){10,25}#!Tom</td></tr></table></td><td class="time">204 ms (2)</td><td class="time">248 ms (2)</td><td class="time">1763 ms (2)</td><td class="time">251 ms (2)</td><td class="time">218 ms (2)</td><td class="time">45 ms (2)</td><td class="time">12207 ms (2)</td><td class="time">1601 ms (2)</td></tr>
      <tr><td class="pattern"><table><tr><td>ing[^a-zA-Z]</td></tr><tr><td class="raptorPattern">ing[^a-zA-Z]</td></tr></table></td><td class="time">142 ms (85956)</td><td class="time">242 ms (85956)</td><td class="time">1143 ms (85956)</td><td class="time">139 ms (85956)</td><td class="time">112 ms (85956)</td><td class="time">54 ms (85956)</td><td class="time">3091 ms (85956)</td><td class="time">657 ms (85956)</td></tr>
      <tr><td class="pattern"><table><tr><td>[a-zA-Z]ing[^a-zA-Z]</td></tr><tr><td class="raptorPattern">[a-zA-Z]ing[^a-zA-Z]</td></tr></table></td><td class="time">1505 ms (85823)</td><td class="time">2372 ms (85823)</td><td class="time">1800 ms (85823)</td><td class="time">142 ms (85823)</td><td class="time">327 ms (85823)</td><td class="time">57 ms (85823)</td><td class="time">6706 ms (85823)</td><td class="time">1375 ms (85823)</td></tr>
      <tr><td class="pattern"><table><tr><td>([a-zA-Z]+ing)</td></tr><tr><td class="raptorPattern">&lt;(ing|:A)+#!ing((ing|:A)*#!ing)*&gt;</td></tr></table></td><td class="time">3993 ms (95863)</td><td class="time">5392 ms (95863)</td><td class="time">2068 ms (95863)</td><td class="time">3004 ms (95863)</td><td class="time">338 ms (95863)</td><td class="time">222 ms (95863)</td><td class="time">26810 ms (95863)</td><td class="time">7039 ms (95863)</td></tr>
      </tbody></table>
    #+END_HTML

    El entorno de pruebas [[https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks][aqui]] (El entorno fue creado por [[https://sourceforge.net/u/dark100/profile/][dark100]] puede
    descargalo desde [[http://sljit.sourceforge.net/regex-test.tgz][aqui]]). Solo descargalo, escribe =make= y ejecuta =runtest=.

* Licencia

  Este proyecto no es de codigo "abierto", es *software libre*, y acorde a
  ello se utiliza la licencia GNU GPL Version 3. Cualquier obra que incluya o
  derive codigo de esta libreria, debera cumplir con los terminos de esta
  licencia.

* Contacto, contribucion y otras cosas

  [[mailto:nasciiboy@gmail.com]]
